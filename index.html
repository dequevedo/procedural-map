<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Medieval Procedural Map (Single HTML)</title>
<style>
  :root{
    /* Updated medieval theme colours: earth tones and desaturated accents */
    --bg:#2f2a23; --panel:#3d3328; --accent:#b89a6b; --muted:#a1886e; --ink:#e5dccc;
    --ok:#5f8a6b; --warn:#b27e3c; --danger:#8c4c3b; --shadow:rgba(0,0,0,.35);
  }
  html,body{height:100%;}
  body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.5 'Palatino Linotype', 'Book Antiqua', Palatino, 'Georgia', serif;overflow:hidden;}
  #ui{
    position:fixed;left:12px;top:12px;
    background:var(--panel);
    border:1px solid #574935;
    border-radius:12px;
    box-shadow:0 10px 30px var(--shadow);
    padding:12px 12px 8px;
    width:310px;
    z-index:10;
  }
  #ui h3{margin:0 0 6px 0;font-size:14px;color:#f3ead3;letter-spacing:.3px;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;}
  .row{display:grid;grid-template-columns:110px 1fr;gap:8px;align-items:center;margin:6px 0}
  .row label{color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;}
  .row input[type="text"], .row input[type="number"], .row select{
    width:100%;padding:6px 8px;background:#2c261f;border:1px solid #4a3e32;border-radius:8px;color:#e5dccc;
    font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;
  }
  .row input[type="range"]{
    /* allow flexbox to control the width of range sliders when used alongside value displays */
    min-width:0;
  }
  .btns{display:flex;gap:8px;margin-top:8px}
  .btn{
    flex:1;
    background:#5a4c3b;
    border:1px solid #7b654e;
    border-radius:10px;
    color:#f0e6d2;
    padding:8px 10px;
    cursor:pointer;
    font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;
  }
  .btn:hover{filter:brightness(1.1)}
  .btn.primary{
    background:linear-gradient(180deg,#806542,#6a5237);
    border:none;
  }
  .btn.export{
    background:linear-gradient(180deg,#5f7e4f,#4e683f);
    border:none;
  }
  #legend{
    position:fixed;left:12px;bottom:12px;
    background:var(--panel);
    border:1px solid #574935;
    border-radius:12px;
    box-shadow:0 10px 30px var(--shadow);
    padding:10px 12px;
    min-width:220px;
    z-index:6;
    max-height:45vh;
    overflow:auto;
  }
  #legend h4{margin:0 0 6px 0;font-size:13px;color:#e2e8f0}
  #legend .item{display:flex;align-items:center;gap:8px;margin:6px 0}
  #legend .sw{width:14px;height:14px;border-radius:3px;border:1px solid #0006}
  #tooltip{position:fixed;pointer-events:none;background:#111827aa;color:#e5e7eb;padding:8px 10px;border-radius:8px;border:1px solid #ffffff18;backdrop-filter: blur(6px);z-index:9;transform:translate(-50%,-110%);white-space:nowrap}
  #tooltip.hidden{display:none}
  #panel{
    position:fixed;right:12px;top:12px;width:360px;max-width:40vw;
    background:var(--panel);
    border:1px solid #574935;
    border-radius:14px;
    box-shadow:0 10px 30px var(--shadow);
    z-index:11;
    display:none;
    flex-direction:column;
    max-height:85vh;
  }
  #panel header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #2a3142}
  #panel header h3{margin:0;font-size:16px}
  #panel .content{padding:12px;overflow:auto}
  .kv{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:8px 0}
  .badge{padding:2px 6px;border-radius:6px;background:#2b3447;color:#e5e7eb;border:1px solid #3a4661;font-size:12px}
  .citymap{width:100%;height:200px;background:#0b0e14;border:1px solid #2a3142;border-radius:10px}
  /* Only the main map canvas should occupy the full viewport. Other canvas elements (e.g., city preview) should not inherit this. */
  canvas#map{display:block;position:fixed;inset:0}
  .notice{
    position:fixed;left:50%;bottom:20px;
    transform:translateX(-50%);
    background:rgba(47,42,35,0.9);
    color:#e5dccc;
    border:1px solid #574935;
    padding:6px 10px;
    border-radius:10px;
    z-index:4;
    font-family:'Georgia','Times New Roman',serif;
  }
  /* Banners behind labels */
  .label-banner{position:absolute}

  /* Tabbed interface styles */
  .tabs{
    display:flex;
    gap:4px;
    margin-bottom:8px;
  }
  .tabBtn{
    flex:1;
    background:#5a4c3b;
    border:1px solid #7b654e;
    border-radius:6px;
    color:#e5dccc;
    padding:4px 6px;
    cursor:pointer;
    font-size:13px;
    font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;
  }
  .tabBtn.active{
    background:#806542;
    border-color:#806542;
  }
  .tabContent{
    display:none;
  }
  .tabContent.active{
    display:block;
  }
</style>
</head>
<body>
  <div id="ui">
    <h3>⚙️ Map Generator</h3>
    <!-- Tab buttons for organizing settings into sections -->
    <div class="tabs">
      <button class="tabBtn" data-tab="tabGeneral">Geral</button>
      <button class="tabBtn" data-tab="tabTerrain">Terreno</button>
      <button class="tabBtn" data-tab="tabCities">Cidades</button>
      <button class="tabBtn" data-tab="tabRoads">Estradas &amp; Rios</button>
      <button class="tabBtn" data-tab="tabColors">Cores</button>
      <button class="tabBtn" data-tab="tabPalette">Paleta</button>
    </div>
    <!-- General settings -->
    <div id="tabGeneral" class="tabContent">
      <div class="row"><label>Seed</label><input id="seed" type="text" placeholder="my-seed" /></div>
      <div class="row"><label>Cities</label><input id="cities" type="number" min="10" max="300" value="120" /></div>
      <div class="row"><label>Rivers</label><input id="rivers" type="number" min="0" max="50" value="12" /></div>
      <div class="row"><label>Water %</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="water" type="range" min="20" max="75" value="45" style="flex:1" />
          <span id="waterVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">45%</span>
        </div>
      </div>
      <div class="row"><label>Chaos</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="chaos" type="range" min="0" max="100" value="45" style="flex:1" />
          <span id="chaosVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">45</span>
        </div>
      </div>
      <div class="row"><label>Detail</label>
        <select id="detail">
          <option value="low">Low (fast)</option>
          <option value="med" selected>Medium</option>
          <option value="high">High</option>
          <option value="ultra">Ultra</option>
        </select>
      </div>
    </div>
    <!-- Terrain settings -->
    <div id="tabTerrain" class="tabContent">
      <div class="row"><label>Montanhas</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="mountains" type="range" min="0" max="100" value="30" style="flex:1" />
          <span id="mountainsVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">30</span>
        </div>
      </div>
      <div class="row"><label>Resolução</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="terrainRes" type="range" min="0.5" max="2.0" step="0.1" value="1.0" style="flex:1" />
          <span id="terrainResVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
      <div class="row"><label>Facções</label><input id="factions" type="number" min="3" max="10" value="5" /></div>
      <div class="row"><label>Limite de Slope</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="slopeLimit" type="range" min="0" max="50" value="15" style="flex:1" />
          <span id="slopeLimitVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">15</span>
        </div>
      </div>
      <div class="row"><label>Escala de Umidade</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="moistureScale" type="range" min="0.5" max="2.0" step="0.1" value="1.0" style="flex:1" />
          <span id="moistureScaleVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
      <div class="row"><label>Escala de Temp.</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="tempScale" type="range" min="0.5" max="2.0" step="0.1" value="1.0" style="flex:1" />
          <span id="tempScaleVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
      <div class="row"><label>Diversidade de Bioma</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="biomeDiv" type="range" min="0.5" max="2.0" step="0.1" value="1.0" style="flex:1" />
          <span id="biomeDivVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
      <!-- New terrain tweak: Peak Frequency -->
      <div class="row"><label>Freq. de Picos</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="peakFreq" type="range" min="0.5" max="2.0" step="0.1" value="1.0" style="flex:1" />
          <span id="peakFreqVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
    </div>
    <!-- City settings -->
    <div id="tabCities" class="tabContent">
      <div class="row"><label>Tamanho Variável</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="citySizeVar" type="range" min="0" max="1.0" step="0.1" value="0.2" style="flex:1" />
          <span id="citySizeVarVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">0.2</span>
        </div>
      </div>
      <div class="row"><label>Agrupamento</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="cityCluster" type="range" min="0" max="2.0" step="0.1" value="1.0" style="flex:1" />
          <span id="cityClusterVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
      <!-- New city tweak: City Spacing -->
      <div class="row"><label>Espaçamento</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="citySpacing" type="range" min="0.5" max="3.0" step="0.1" value="1.0" style="flex:1" />
          <span id="citySpacingVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
    </div>
    <!-- Road & river settings -->
    <div id="tabRoads" class="tabContent">
      <div class="row"><label>Densidade de Estradas</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="roadDensity" type="range" min="0.1" max="1.0" step="0.05" value="0.35" style="flex:1" />
          <span id="roadDensityVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">0.35</span>
        </div>
      </div>
      <div class="row"><label>Largura dos Rios</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="riverWidth" type="range" min="0.5" max="3.0" step="0.1" value="1.0" style="flex:1" />
          <span id="riverWidthVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
      <!-- New road tweak: Curvatura -->
      <div class="row"><label>Curvatura das Estradas</label>
        <div style="display:flex;align-items:center;gap:4px">
          <input id="roadCurvature" type="range" min="0.5" max="2.0" step="0.1" value="1.0" style="flex:1" />
          <span id="roadCurvatureVal" style="min-width:30px;text-align:right;color:#d6c4a5;font-family:'Palatino Linotype','Book Antiqua',Palatino,'Georgia',serif;">1.0</span>
        </div>
      </div>
    </div>
    <!-- Colour settings -->
    <div id="tabColors" class="tabContent">
      <div class="row"><label>Oceano</label><input id="colorOcean" type="color" value="#3d7ed0" /></div>
      <div class="row"><label>Terra</label><input id="colorLand" type="color" value="#8fb065" /></div>
      <div class="row"><label>Colinas</label><input id="colorHills" type="color" value="#6f6549" /></div>
      <div class="row"><label>Montanhas</label><input id="colorMountains" type="color" value="#8a8a8a" /></div>
      <div class="row"><label>Rios</label><input id="colorRiver" type="color" value="#4fb7ff" /></div>
      <div class="row"><label>Estradas</label><input id="colorRoad" type="color" value="#caa66a" /></div>
    </div>
    <!-- Palette settings -->
    <div id="tabPalette" class="tabContent">
      <div id="colorList" style="display:flex;flex-direction:column;gap:6px;"></div>
      <button id="addColor" class="btn" style="margin-top:4px;">+ Adicionar Cor</button>
    </div>
    <div class="btns">
      <button id="gen" class="btn primary">Generate</button>
      <button id="export" class="btn export">Export PNG</button>
    </div>
  </div>
  <div id="legend"><h4>🏳️ Factions</h4><div id="legendItems"></div></div>
  <div id="panel">
    <header><h3 id="panelTitle">City</h3><button id="panelClose" class="btn" style="flex:0 0 auto;padding:4px 8px">Close</button></header>
    <div class="content">
      <!-- Minimap placed at the top of the city panel -->
      <canvas id="cityMini" class="citymap" style="margin-bottom:10px;"></canvas>
      <!-- Basic info about the settlement -->
      <div class="kv">
        <div><div class="badge" id="panelType">Type</div></div>
        <div><div class="badge" id="panelFaction">Faction</div></div>
      </div>
      <div class="kv">
        <div>Population</div><div id="panelPop">—</div>
        <div>Prosperity</div><div id="panelPros">—</div>
      </div>
      <p id="panelDesc" style="color:#d6c4a5"></p>
    </div>
  </div>
  <div id="tooltip" class="hidden"></div>
  <canvas id="map"></canvas>
  <div class="notice" id="hint">Drag to pan • Wheel to zoom (focuses cursor) • Hover for tooltip • Click to open city</div>

  <!-- City preview overlay: shows a minimap and information when a city is clicked. Placed in the top right corner. -->
  <div id="cityPreview" style="display:none; position:fixed; top:12px; right:12px; width:320px; max-width:40vw; background:var(--panel); border:1px solid #574935; border-radius:14px; box-shadow:0 10px 30px var(--shadow); z-index:12; color:var(--ink); overflow:hidden;">
    <div style="position:relative;">
      <canvas id="previewMini" class="citymap" style="width:100%; height:200px; background:#0b0e14; border-bottom:1px solid #574935;"></canvas>
      <button id="previewClose" class="btn" style="position:absolute; top:4px; right:4px; padding:2px 6px; font-size:12px; line-height:1;">×</button>
    </div>
    <div id="previewInfo" style="padding:10px; line-height:1.4; font-size:14px;"></div>
  </div>
<script>
// ===============================
// Medieval Procedural Map — Single File
// No external dependencies. All code here.
// Comments and identifiers in English per user preference.
// ===============================
(() => {
  // ---------- Utilities
  const DPI = () => (window.devicePixelRatio || 1);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const mix = lerp;
  const randFromSeed = (str) => {
    // xmur3 + mulberry32
    function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0;}}
    const seed = xmur3(str||('seed-'+Math.random()));
    let a=seed(), b=seed(), c=seed(), d=seed();
    return function(){
      // sfc32
      a>>>=0; b>>>=0; c>>>=0; d>>>=0; 
      let t=(a+b)|0; a=b^(b>>>9); b=(c+(c<<3))|0; c=(c<<21)|(c>>>11); d=(d+1)|0; t=(t+d)|0; c=(c+t)|0; return (t>>>0)/4294967296;
    }
  };
  const seededShuffle = (arr, rnd) => { for (let i=arr.length-1;i>0;i--){const j=Math.floor(rnd()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; };
  const hash2 = (x,y) => { // deterministic hash -> 0..1
    let h = (x*374761393 + y*668265263) ^ (x*1442695040888963n?0:0); // keep simple int math
    // JS integer overflow is okay; fallback pure JS:
    h = (x*92837111 ^ y*689287499) >>> 0; 
    return (h & 0xffffffff) / 0xffffffff;
  };
  // 2D value noise (fast, tiled via lattice). fBm for chaos control.
  function makeValueNoise2D(seedStr){
    const rnd = randFromSeed('noise-'+seedStr);
    const perm = new Uint16Array(512);
    for(let i=0;i<256;i++) perm[i]=i;
    seededShuffle(perm.subarray(0,256), rnd);
    for(let i=0;i<256;i++) perm[256+i]=perm[i];
    const grad = new Float32Array(512);
    for(let i=0;i<512;i++) grad[i]=rnd();
    const fade = t=>t*t*(3-2*t); // smoothstep
    function value(x,y){
      const xi = Math.floor(x)&255, yi=Math.floor(y)&255;
      const xf = x - Math.floor(x), yf = y - Math.floor(y);
      const aa = perm[perm[xi] + yi];
      const ab = perm[perm[xi] + yi+1];
      const ba = perm[perm[xi+1] + yi];
      const bb = perm[perm[xi+1] + yi+1];
      const u = fade(xf), v = fade(yf);
      const x1 = mix(grad[aa], grad[ba], u);
      const x2 = mix(grad[ab], grad[bb], u);
      return mix(x1, x2, v); // 0..1 approx
    }
    function fbm(x,y,octaves=5,lacunarity=2,gain=.5){
      let amp=1, freq=1, sum=0, norm=0;
      for(let i=0;i<octaves;i++){
        sum += value(x*freq, y*freq)*amp;
        norm += amp;
        amp *= gain; freq *= lacunarity;
      }
      return sum/norm; // ~0..1
    }
    return {value, fbm};
  }

  // Rounded rectangle helper
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // ---------- Palettes (step colours, no smooth gradients)
  // Colour palettes. These are declared with let so they can be overridden when the user selects custom colours.
  // We define both a traditional stepped palette for water (OceanSteps) and a single variable MapColors for all land elevations.
  let OceanSteps = ["#0b265a","#0f3275","#154091","#1d53aa","#2b67bf","#3d7ed0","#5396de","#6dafea"];
  const Beach = "#e9d8a6";
  // MapColors is an array of colours used for all terrain elevations above the beach. The number of entries can vary depending on the user's palette.
  let MapColors = ["#dfe8b8","#c9d29c","#b0c27b","#8fb065","#6b9b59","#4e8a4f","#3e6f45","#355a3d","#2e4b36"];
  // Separate colours for linear features
  let RiverColor = "#4fb7ff";
  let RoadColor = "#caa66a";
  const RoadEdge = "#6e5430";
  const BridgeColor = "#d7d7d7";

  // ---------- Core State
  const canvas = document.getElementById('map');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const panel = document.getElementById('panel');
  const panelTitle = document.getElementById('panelTitle');
  const panelType = document.getElementById('panelType');
  const panelFaction = document.getElementById('panelFaction');
  const panelPop = document.getElementById('panelPop');
  const panelPros = document.getElementById('panelPros');
  const panelDesc = document.getElementById('panelDesc');
  const panelClose = document.getElementById('panelClose');
  const cityMini = document.getElementById('cityMini');
  const legendItems = document.getElementById('legendItems');

  // Elements for the new city preview overlay
  const cityPreview = document.getElementById('cityPreview');
  const previewMini = document.getElementById('previewMini');
  const previewInfo = document.getElementById('previewInfo');
  const previewClose = document.getElementById('previewClose');

  let W=0, H=0, SCALE=1, panX=0, panY=0;
  let isDragging=false, dragStartX=0, dragStartY=0, panStartX=0, panStartY=0;
  let worldW=1024, worldH=768; // logical map size in world units
  let baseOff = document.createElement('canvas'); // base terrain + rivers
  let baseCtx = baseOff.getContext('2d');
  let overlayOff = document.createElement('canvas'); // roads + cities + labels
  let overlayCtx = overlayOff.getContext('2d');

  let CURRENT = {
    seed: 'demo', cities: [], pois: [], factions: [], roads: [], rivers: [], riverMask:null,
    waterLevel: .45, chaos: .45, detail:'med',
    height: null, slope: null, landMask:null, coastSegments:[], legend:[],
    // Track currently hovered city or point of interest for animation
    hoverCity: null,
    hoverPoi: null,
  };

  // ---------- Coordinate transforms
  function resizeCanvas(){
    const dpr = DPI();
    W = canvas.width = Math.floor(window.innerWidth*dpr);
    H = canvas.height = Math.floor(window.innerHeight*dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    // Keep existing pan/zoom, only need redraw
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  function worldToScreen(x,y){ return { x: x*SCALE + panX, y: y*SCALE + panY }; }
  function screenToWorld(x,y){ return { x: (x - panX)/SCALE, y: (y - panY)/SCALE }; }

  // Zoom focusing the cursor position
  function onWheel(e){
    e.preventDefault();
    const {clientX, clientY} = e;
    const rect = canvas.getBoundingClientRect();
    const sx = (clientX - rect.left) * DPI();
    const sy = (clientY - rect.top) * DPI();
    const before = screenToWorld(sx, sy);
    const zoom = Math.exp(-e.deltaY * 0.001);
    const newScale = clamp(SCALE * zoom, 0.3, 4);
    SCALE = newScale;
    const after = {x: before.x, y: before.y};
    panX = sx - after.x * SCALE;
    panY = sy - after.y * SCALE;
    draw();
  }

  function onMouseDown(e){
    isDragging = true;
    dragStartX = e.clientX; dragStartY = e.clientY;
    panStartX = panX; panStartY = panY;
  }
  function onMouseMove(e){
    if(isDragging){
      const dx = (e.clientX - dragStartX) * DPI();
      const dy = (e.clientY - dragStartY) * DPI();
      panX = panStartX + dx; panY = panStartY + dy;
      draw();
    }
    // Hover tooltip
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPI();
    const sy = (e.clientY - rect.top) * DPI();
    const wp = screenToWorld(sx, sy);
    const hit = hitTest(wp.x, wp.y);
    if(hit){
      tooltip.classList.remove('hidden');
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top = e.clientY + 'px';
      tooltip.innerHTML = hit.tooltip;
      // Update hover identifiers for animation effects
      if(hit.kind==='city'){
        CURRENT.hoverCity = hit.data.id;
        CURRENT.hoverPoi = null;
      } else if(hit.kind==='poi'){
        CURRENT.hoverCity = null;
        CURRENT.hoverPoi = hit.data.id;
      }
    } else {
      tooltip.classList.add('hidden');
      CURRENT.hoverCity = null;
      CURRENT.hoverPoi = null;
    }
    // Redraw to reflect hover changes when not dragging
    if(!isDragging){
      draw();
    }
  }
  function onMouseUp(){ isDragging=false; }
  function onClick(e){
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPI();
    const sy = (e.clientY - rect.top) * DPI();
    const wp = screenToWorld(sx, sy);
    const hit = hitTest(wp.x, wp.y);
    if(hit && hit.kind==='city'){
      openCityPanel(hit.data);
    }
  }
  canvas.addEventListener('wheel', onWheel, {passive:false});
  canvas.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('click', onClick);

  panelClose.addEventListener('click', ()=>{panel.style.display='none'});

  // Close button for the city preview overlay
  if(previewClose){
    previewClose.addEventListener('click', () => {
      cityPreview.style.display = 'none';
    });
  }

  // ---------- Map Generation Pipeline
  function generate(opts){
    const seed = opts.seed || 'seed';
    const detail = opts.detail || 'med';
    const rnd = randFromSeed(seed);
    CURRENT.seed = seed;

    // Apply user-selected colors to palette arrays and road/river colours. Generate gradients by lightening the base colour.
    if(opts.colors){
      const col = opts.colors;
      OceanSteps = generateGradient(col.ocean || '#2b67bf', 8, 0.6);
      // Generate a gradient for MapColors from the selected land colour. The gradient length defaults to the current palette length to preserve distribution.
      const steps = MapColors.length > 0 ? MapColors.length : 9;
      MapColors = generateGradient(col.land || '#8fb065', steps, 0.5);
      // If the user provided explicit hill/mountain colours we incorporate them as additional stops in MapColors. This ensures all land colours come from the same list regardless of how many the user adds.
      if(col.hills){
        MapColors.push(col.hills);
      }
      if(col.mountains){
        MapColors.push(col.mountains);
      }
      RiverColor = col.river || RiverColor;
      RoadColor = col.road || RoadColor;
    }

    // Resolution by detail (logical world size). Multiply by devicePixelRatio to improve visual fidelity on high-density screens.
    const dpr = DPI();
    const baseRes = {low: 800, med: 1200, high: 1600, ultra: 2400};
    const base = baseRes[detail] || baseRes['med'];
    // Apply terrain resolution scaling. A factor >1 increases pixel density, <1 decreases it.
    const resFactor = opts.terrainRes || 1.0;
    worldW = Math.floor(base * resFactor * dpr);
    worldH = Math.floor((base * 0.65) * resFactor * dpr);

    // Prepare canvases
    baseOff.width = worldW; baseOff.height = worldH;
    overlayOff.width = worldW; overlayOff.height = worldH;

    // Noise & heightfield
    const {fbm} = makeValueNoise2D(seed);
    const chaos = opts.chaos ?? .45; // 0..1
    // Mountain weighting based on user slider (0..100). Increase this to emphasize mountains in the heightfield.
    const mIntensity = opts.mountains !== undefined ? opts.mountains : 30;
    const waterPct = (opts.waterPct ?? .45)/100; // expect 20..75 in UI, normalize later

    // Generate raw height, then warp for islands: radial falloff
    const w = worldW, h = worldH;
    const height = new Float32Array(w*h);
    const slope = new Float32Array(w*h);

    // Radial mask for island continents
    const cx=w/2, cy=h/2; const maxD = Math.hypot(cx,cy);

    // Octaves depend on detail and chaos
    const oct = clamp(Math.round(4 + chaos*4), 3, 8);
    const lac = 2.0; const gain = 0.5 + chaos*0.35;

    // Precompute height
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const nx = x/w - 0.5, ny = y/h - 0.5;
        const d = Math.hypot(nx,ny);
        const island = clamp(1.0 - d*1.35, 0, 1); // more chaotic coast
        // Multi-layer noise: combine low-frequency base noise, a domain-warped layer, and ridged noise for mountains.
        // Primary low-frequency terrain noise
        const n1 = fbm(x * 0.004 + chaos * 1.33, y * 0.004 - chaos * 2.17, oct, lac, gain);
        // Secondary medium-frequency noise used for warping
        const n2 = fbm(x * 0.012 + 47.3, y * 0.012 - 13.7, 3, 2.1, 0.55);
        // Warp coordinates using n2 to break up repeating patterns
        const warpX = x + (n2 - 0.5) * 100;
        const warpY = y + (n2 - 0.5) * 100;
        const n3 = fbm(warpX * 0.006, warpY * 0.006, 4, 2.0, 0.55);
        const baseVal = (n1 + n3) * 0.5;
        // Ridged noise for mountains: emphasise peaks by inverting the absolute difference from mid-level
        // Ridged noise frequency scaled by user-defined peakFreq (default 1.0). Higher values create more frequent peaks.
        const freq = (opts.peakFreq !== undefined ? opts.peakFreq : 1.0);
        const ridgedSample = fbm(x * 0.02 * freq + 97, y * 0.02 * freq - 37, 5, 2.2, 0.55);
        const ridged = 1 - Math.abs(ridgedSample * 2 - 1);
        // Blend base terrain and ridged mountains based on user intensity
        const mWeight = (mIntensity / 100);
        let val = baseVal * (1 - mWeight) + ridged * mWeight;
        // Apply island mask: blend towards base terrain near shore to soften edges
        val = val * island + (baseVal * 0.1) * (1 - island);
        height[y*w + x] = val;
      }
    }
    // Normalize & water level
    let min=1e9,max=-1e9; for(let i=0;i<height.length;i++){ const v=height[i]; if(v<min)min=v; if(v>max)max=v; }
    const inv = 1/(max-min);
    for(let i=0;i<height.length;i++){ height[i] = (height[i]-min)*inv; }

    // Adjust global water threshold by target water % via binary search
    const desiredWater = waterPct; // 0.2..0.75 (UI enforces)
    let lo=0, hi=1, lvl=0.5;
    for(let k=0;k<10;k++){
      lvl = (lo+hi)*0.5;
      let cnt=0; for(let i=0;i<height.length;i++) if(height[i]<lvl) cnt++;
      const ratio = cnt/height.length;
      if(ratio>desiredWater) hi=lvl; else lo=lvl;
    }
    const waterLevel = lvl; CURRENT.waterLevel=waterLevel;

    // Slope (for placement & rivers)
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i=y*w+x;
        const dzdx=(height[i+1]-height[i-1])*0.5;
        const dzdy=(height[i+w]-height[i-w])*0.5;
        slope[i]=Math.hypot(dzdx,dzdy);
      }
    }

    // Land/Water mask
    const landMask = new Uint8Array(w*h);
    for(let i=0;i<height.length;i++) landMask[i] = height[i]>=waterLevel?1:0;

    // Compute temperature and moisture maps for biome classification. Temperature is influenced
    // by latitude (north to south) with some noise, and moisture is driven by a separate noise
    // function. These arrays will later inform biome colours and city climate descriptions.
    const tempNoiseGen = makeValueNoise2D(seed + '|temp');
    const moistNoiseGen = makeValueNoise2D(seed + '|moist');
    const temperature = new Float32Array(w*h);
    const moistureArr = new Float32Array(w*h);
    // Apply temperature and moisture scales from options
    const tempScale = opts.tempScale ?? 1.0;
    const moistureScale = opts.moistureScale ?? 1.0;
    for(let yy=0; yy<h; yy++){
      const lat = 1 - (yy / h); // 1 at top (north), 0 at bottom (south)
      for(let xx=0; xx<w; xx++){
        const idx = yy*w + xx;
        // Temperature: base on latitude plus noise variation scaled by tempScale
        let t = lat;
        const noiseT = tempNoiseGen.fbm(xx * 0.005, yy * 0.005, 3, 2.0, 0.5);
        t += (noiseT - 0.5) * 0.3 * tempScale;
        temperature[idx] = clamp(t, 0, 1);
        // Moisture: noise value scaled by moistureScale
        const noiseM = moistNoiseGen.fbm(xx * 0.02 + 127.5, yy * 0.02 - 93.3, 3, 2.0, 0.5);
        let m = noiseM * moistureScale;
        moistureArr[idx] = clamp(m, 0, 1);
      }
    }

    // Coast outline via grid-edge scan (marching squares-lite)
    const coastSegments = [];
    for(let y=0;y<h-1;y++){
      for(let x=0;x<w-1;x++){
        const i=y*w+x;
        const a=landMask[i], b=landMask[i+1], c=landMask[i+w], d=landMask[i+w+1];
        const code = a*8+b*4+c*2+d*1;
        if(code===0||code===15) continue; // fully water or land
        // Collect mid-edge points depending on case
        const mx=x+.5, my=y+.5;
        const edges=[];
        if(a!==b) edges.push({x:mx, y:y});
        if(b!==d) edges.push({x:x+1, y:my});
        if(c!==d) edges.push({x:mx, y:y+1});
        if(a!==c) edges.push({x:x, y:my});
        if(edges.length>=2){ coastSegments.push(edges); }
      }
    }

    // Rivers via downhill flow accumulation from random high points
    const riverCount = clamp(Math.round(opts.rivers ?? 10), 0, 60);
    const flow = new Float32Array(w*h);
    const riverMask = new Uint8Array(w*h);

    // Pick sources at elevated, inland cells
    const candidates = [];
    for(let y=2;y<h-2;y++){
      for(let x=2;x<w-2;x++){
        const i=y*w+x; const elev=height[i];
        if(landMask[i] && elev>waterLevel+0.08) candidates.push({x,y,elev});
      }
    }
    seededShuffle(candidates, rnd);
    const sources = candidates.slice(0, riverCount*3); // pick extra; we'll prune short ones

    const rivers = [];
    function stepDownhill(x,y){
      // move to lowest neighbor (8-neighborhood) with slight randomness
      let bestX=x, bestY=y, best=height[y*w+x];
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        if(dx===0&&dy===0) continue; const nx=x+dx, ny=y+dy; if(nx<1||ny<1||nx>=w-1||ny>=h-1) continue;
        const z=height[ny*w+nx] + (Math.abs(dx)+Math.abs(dy)>1?0.002:0) + rnd()*0.001; // prefer cardinal
        if(z<best){ best=z; bestX=nx; bestY=ny; }
      }
      return {x:bestX,y:bestY,val:best};
    }

    for(let s=0,added=0; s<sources.length && added<riverCount; s++){
      let {x,y} = sources[s];
      // Walk downhill until water or edge, accumulate flow
      const path=[]; let safety=0;
      if(!landMask[y*w+x]) continue;
      while(safety++<5000){
        path.push({x,y});
        const i=y*w+x;
        flow[i]+=1;
        // Delta branching near sea
        if(height[i] < waterLevel+0.01){ break; }
        const nxt = stepDownhill(x,y);
        if(nxt.x===x && nxt.y===y) break; // flat pit
        x=nxt.x; y=nxt.y;
        if(x<=1||y<=1||x>=w-2||y>=h-2) break;
      }
      if(path.length>40){
        // Mark mask with variable width by downstream flow
        for(let k=0;k<path.length;k++){
          const p=path[k]; const i=p.y*w+p.x; const f = flow[i];
          const radius = Math.floor(1 + Math.min(6, Math.sqrt(f)*0.6 + k/path.length*1.5));
          for(let ry=-radius;ry<=radius;ry++) for(let rx=-radius;rx<=radius;rx++){
            const nx=p.x+rx, ny=p.y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue;
            const di = ny*w+nx; riverMask[di]=1;
          }
        }
        // Build a simplified polyline for drawing
        const simplified = simplifyPath(path, 1.2);
        rivers.push(simplified);
        added++;
      }
    }

    // Cities & POIs placement
    const totalCities = clamp(parseInt(opts.cities || 120), 5, 400);
    const citySpots = [];
    // Determine slope threshold from options (range 0..50). Convert to 0..0.5.
    const slopeThreshold = (opts.slopeLimit !== undefined ? opts.slopeLimit : 15) / 100;
    for(let y=3;y<h-3;y+=3){
      for(let x=3;x<w-3;x+=3){
        const i=y*w+x; if(!landMask[i]) continue; 
        if(height[i] < waterLevel+0.01) continue; // avoid swamps
        // Prefer flatter ground & near rivers/coast moderately
        const s = slope[i]; if(s > slopeThreshold) continue; // too steep for settlement
        let score = (height[i]-waterLevel)*2.0 + (0.12 - s)*2.5;
        // proximity to river
        const nearRiver = isNearMask(x,y,riverMask,w,h,4)?1:0; score += nearRiver*0.25;
        citySpots.push({x,y,score});
      }
    }
    // Sort spots by descending score
    citySpots.sort((a,b)=>b.score-a.score);
    // Distribute candidate spots across the map to avoid clustering in the centre.
    // We build a grid over the map and pick the best spot from each cell. Then
    // prepend these distributed spots to the master list so that at least one
    // settlement spawns in each region. This helps ensure that when the map
    // resolution or mountain intensity changes, cities are not all drawn toward
    // the centre.
    (function distributeCitySpots(){
      const spotsNeeded = totalCities;
      // Compute grid dimensions proportional to sqrt of desired city count. A higher
      // multiplier yields more cells (and thus more distributed spots). The 0.8
      // multiplier was chosen empirically to balance spread and density.
      // Adjust grid dimensions by citySpacing factor: larger citySpacing yields fewer cells (larger spacing).
      const spacingFactor = opts.citySpacing !== undefined ? opts.citySpacing : 1.0;
      const baseGridX = Math.sqrt(spotsNeeded) * 0.8;
      const gridX = Math.max(3, Math.floor(baseGridX / spacingFactor));
      const gridY = Math.max(2, Math.floor(gridX * (h / w)));
      const cellW = w / gridX;
      const cellH = h / gridY;
      const bestInCell = new Array(gridX * gridY).fill(null);
      for(const spot of citySpots){
        const ix = Math.min(gridX - 1, Math.floor(spot.x / cellW));
        const iy = Math.min(gridY - 1, Math.floor(spot.y / cellH));
        const index = iy * gridX + ix;
        const existing = bestInCell[index];
        if(!existing || spot.score > existing.score){
          bestInCell[index] = spot;
        }
      }
      const distributed = bestInCell.filter(Boolean);
      if(distributed.length){
        // Sort distributed spots so that higher quality spots spawn earlier
        distributed.sort((a,b)=>b.score-a.score);
        // Remove duplicates from citySpots to avoid placing the same spot twice
        const distributedSet = new Set(distributed);
        const remainder = citySpots.filter(s => !distributedSet.has(s));
        // Replace citySpots with distributed followed by remainder. This ensures that
        // the first `gridX*gridY` placements come from across the map.
        citySpots.length = 0;
        Array.prototype.push.apply(citySpots, distributed.concat(remainder));
      }
    })();

    const taken = new Uint8Array(w*h);
    const cities = [];
    const types = ['village','town','city','capital','port'];

    function isNearWater(x,y,dist){
      const d=dist|0; for(let ry=-d;ry<=d;ry++) for(let rx=-d;rx<=d;rx++){
        const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; const ii=ny*w+nx; if(!landMask[ii]) return true; }
      return false;
    }

    // Factions
    // Determine number of factions: use user-provided value if present, otherwise random within 3..7.
    const factionCount = opts.factions && opts.factions > 0 ? clamp(opts.factions, 3, 10) : clamp(Math.floor(4 + rnd()*4), 3, 7);
    const factions = [];
    const hueBase = rnd();
    for(let i=0;i<factionCount;i++){
      const hue = (hueBase + i/factionCount*0.9) % 1;
      const col = hslToHex(hue, 0.55, 0.55);
      factions.push({id:i, name: makeFactionName(rnd), color:col});
    }

    // Place cities, avoiding collisions
    for(let i=0,placed=0; i<citySpots.length && placed<totalCities; i++){
      const c = citySpots[i];
      const ix=c.y*w+c.x; if(taken[ix]) continue;
      // spacing
      if(hasNeighborTaken(taken,w,h,c.x,c.y, 14)) continue;
      const nearSea = isNearWater(c.x,c.y,10);
      const t = nearSea && rnd()<0.3 ? 'port' : chooseType(rnd);
      const pop = Math.floor( (t==='village'?200+(rnd()*800): t==='town'? 1200+(rnd()*3000): t==='city'? 8000+(rnd()*12000): t==='capital'? 20000+(rnd()*40000) : 1500+(rnd()*3000)) );
      const prosp = ['poor','modest','prosperous','rich'][Math.floor(rnd()*4)];
      // Temporarily assign random faction; will reassign later to group cities by faction
      const faction = Math.floor(rnd()*factions.length);
      const name = makePlaceName(rnd, t);
      cities.push({id:placed, name, type:t, x:c.x, y:c.y, pop, faction, prosperity:prosp});
      markTaken(taken,w,h,c.x,c.y, 14);
      placed++;
    }

    // Cluster cities by faction: assign each faction a cluster centre and assign cities to nearest centre.
    if(factions.length && cities.length){
      // Choose cluster centres from the largest cities by population
      const sortedByPop = cities.slice().sort((a,b)=>b.pop-a.pop);
      const centres = [];
      for(let i=0;i<factions.length;i++){
        const c0 = sortedByPop[i % sortedByPop.length];
        centres.push({x: c0.x, y: c0.y});
      }
      for(const c of cities){
        let bestIdx = 0;
        let bestDist = Infinity;
        for(let i=0;i<centres.length;i++){
          const cc = centres[i];
          const d = Math.hypot(c.x - cc.x, c.y - cc.y);
          if(d < bestDist){ bestDist = d; bestIdx = i; }
        }
        c.faction = bestIdx;
      }
    }

    // Assign multi-tile shapes for cities based on size. Cities occupy multiple connected pixels.
    // Each city type has a predefined number of tiles. Generate connected shapes via random growth.
    const typeSize = { village:1, town:4, city:8, capital:12, port:6 };
    // Map of occupied tiles to prevent overlap: key = y*w + x => cityId
    const cityTileMap = new Int32Array(w * h);
    cityTileMap.fill(-1);
    function getNeighbours(x,y){
      return [ [x-1,y], [x+1,y], [x,y-1], [x,y+1] ];
    }
    for(const city of cities){
      // Determine tile count for this city type, applying size variation from options
      let baseCount = typeSize[city.type] || 1;
      if(opts.citySizeVar){
        const varFactor = 1 + (rnd() * 2 - 1) * opts.citySizeVar;
        baseCount = Math.max(1, Math.round(baseCount * varFactor));
      }
      const count = baseCount;
      const tiles = [];
      const set = new Set();
      // Start with the centre tile
      let key = city.y * w + city.x;
      tiles.push({x: city.x, y: city.y});
      set.add(key);
      cityTileMap[key] = city.id;
      // Grow by selecting random neighbours until reaching count
      let attempts = 0;
      while(tiles.length < count && attempts < 100){
        attempts++;
        // Pick a random tile from current shape
        const base = tiles[Math.floor(rnd() * tiles.length)];
        const neighbours = getNeighbours(base.x, base.y);
        // Shuffle neighbours
        for(let i=neighbours.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [neighbours[i], neighbours[j]]=[neighbours[j], neighbours[i]]; }
        let placed = false;
        for(const [nx, ny] of neighbours){
          if(nx<0 || ny<0 || nx>=w || ny>=h) continue;
          const idx = ny * w + nx;
          if(!landMask[idx]) continue; // must be land
          if(cityTileMap[idx] !== -1) continue; // avoid overlap
          // Accept slight slopes only
          if(slope[idx] > 0.15) continue;
          // Add tile
          tiles.push({x:nx, y:ny});
          set.add(idx);
          cityTileMap[idx] = city.id;
          placed = true;
          break;
        }
        if(!placed) continue;
      }
      city.tiles = tiles;
    }
    // Expose tile map in CURRENT later
    // After assigning shapes, store the tile map on the global CURRENT state. This
    // allows us to look up which city occupies each world cell when hit testing.
    CURRENT.cityTileMap = cityTileMap;

    // POIs
    const poiTypes = ['ruins','tower','shrine','crypt'];
    const pois = [];
    let tryPoi = 0; while(pois.length < Math.min(60, Math.floor(totalCities*0.4)) && tryPoi < 5000){
      tryPoi++;
      const x = Math.floor(rnd()*w), y=Math.floor(rnd()*h); const i=y*w+x;
      if(!landMask[i]) continue; if(slope[i]>0.14) continue; if(isNearAnyCity(cities,x,y, 18)) continue;
      const t = poiTypes[Math.floor(rnd()*poiTypes.length)];
      pois.push({id:pois.length, type:t, x,y, name: makePOIName(rnd,t)});
    }

    // Roads: connect major hubs via MST + some local links. Organic curves.
    const hubs = cities.filter(c=>['town','city','capital','port'].includes(c.type));
    // Pick top ~50 hubs by pop (cap for perf)
    hubs.sort((a,b)=>b.pop-a.pop); const maxHubs = Math.min(50, hubs.length);
    const nodes = hubs.slice(0,maxHubs);
    const edges = computeMST(nodes, (a,b)=>Math.hypot(a.x-b.x,a.y-b.y));
    // Add a handful of extra local connections
    // Extra road connections: proportional to road density setting (default ~0.35)
    const rd = opts.roadDensity !== undefined ? opts.roadDensity : 0.35;
    const extra = Math.floor(nodes.length * rd);
    for(let k=0;k<extra;k++){
      const a = nodes[Math.floor(rnd()*nodes.length)];
      // nearest neighbor not already connected
      let best=null,bestD=1e9;
      for(const b of nodes){ if(a===b) continue; const d=Math.hypot(a.x-b.x,a.y-b.y); if(d<bestD){bestD=d;best=b;} }
      edges.push([a,best]);
    }

    // Build organic road polylines with jitter & bezier smoothing
    const roads = [];
    const riverMaskSet = riverMask;
    // Prepare a noise generator for road wobble
    const roadNoise = makeValueNoise2D(seed + '|roads');
    // Major roads: MST + extra connections
    for(const [a,b] of edges){
      // Avoid duplicate connections between the same pair of nodes
      let exists = false;
      for(const r of roads){
        if((r.a===a && r.b===b) || (r.a===b && r.b===a)){
          exists = true;
          break;
        }
      }
      if(exists) continue;
      // Terrain-aware path using A*
      let basePath = astarPath(a.x, a.y, b.x, b.y, height, slope, waterLevel);
      // Simplify and apply natural noise wobble
      const simplified = simplifyPath(basePath, 1.2);
      const roadCurv = opts.roadCurvature !== undefined ? opts.roadCurvature : 1.0;
      const wobbled = applyRoadNoise(simplified, roadNoise, 4 * roadCurv);
      // Smooth the path
      const curve = smoothPath(wobbled);
      const bridges = computeBridges(curve, riverMaskSet, w,h);
      roads.push({a,b, path:curve, bridges, level:'major'});
    }
    // Minor roads: connect towns and ports to the nearest city or capital (primary hubs)
    const hubsByType = cities.filter(c => c.type==='city' || c.type==='capital');
    for(const c of cities){
      if(c.type==='town' || c.type==='port'){
        // find nearest hub
        let best=null,bestDist=1e9;
        for(const h of hubsByType){ if(h===c) continue; const d=Math.hypot(c.x-h.x,c.y-h.y); if(d<bestDist){ bestDist=d; best=h; } }
        if(best){
          // Skip if connection already exists between these endpoints
          let exists = false;
          for(const r of roads){
            if((r.a===c && r.b===best) || (r.a===best && r.b===c)){ exists = true; break; }
          }
          if(!exists){
            // Use simple jittered path for minor roads to save computation
            const poly = jitteredPath(c.x, c.y, best.x, best.y, rnd, landMask, w, h);
            const curve = smoothPath(poly);
            const bridges = computeBridges(curve, riverMaskSet, w,h);
            roads.push({a:c,b:best, path:curve, bridges, level:'minor'});
          }
        }
      }
    }
    // Trail roads: connect villages to nearest town or city (with probability to avoid clutter)
    const hubsForTrails = cities.filter(c => c.type==='town' || c.type==='city' || c.type==='capital' || c.type==='port');
    for(const c of cities){
      if(c.type==='village'){
        const rd = opts.roadDensity !== undefined ? opts.roadDensity : 0.35;
        if(rnd() < rd){ // probability to connect a village based on road density
          let best=null,bestDist=1e9;
          for(const h of hubsForTrails){ const d=Math.hypot(c.x-h.x,c.y-h.y); if(d<bestDist){ bestDist=d; best=h; } }
          if(best){
            // Skip if connection already exists
            let exists = false;
            for(const r of roads){
              if((r.a===c && r.b===best) || (r.a===best && r.b===c)){ exists = true; break; }
            }
            if(!exists){
              // Use simple jittered path for trail roads
              const poly = jitteredPath(c.x, c.y, best.x, best.y, rnd, landMask, w, h);
              const curve = smoothPath(poly);
              const bridges = computeBridges(curve, riverMaskSet, w,h);
              roads.push({a:c,b:best, path:curve, bridges, level:'trail'});
            }
          }
        }
      }
    }

    // Prepare legend HTML
    legendItems.innerHTML = '';
    for(const f of factions){
      const div = document.createElement('div'); div.className='item';
      div.innerHTML = `<span class="sw" style="background:${f.color}"></span><span>${escapeHtml(f.name)}</span>`;
      legendItems.appendChild(div);
    }

    // Store
    // Build a road occupancy mask: for each cell mark the highest road level present.
    // Levels: 0 = none, 1 = trail, 2 = minor, 3 = major.
    const roadMask = new Uint8Array(w * h);
    // Bresenham line function to iterate cells along a line between two integer points.
    function bresenhamLine(x0, y0, x1, y1, callback){
      x0 = Math.round(x0); y0 = Math.round(y0);
      x1 = Math.round(x1); y1 = Math.round(y1);
      const dx = Math.abs(x1 - x0);
      const dy = Math.abs(y1 - y0);
      const sx = (x0 < x1 ? 1 : -1);
      const sy = (y0 < y1 ? 1 : -1);
      let err = dx - dy;
      let x = x0, y = y0;
      while(true){
        callback(x, y);
        if(x === x1 && y === y1) break;
        const e2 = err * 2;
        if(e2 > -dy){ err -= dy; x += sx; }
        if(e2 < dx){ err += dx; y += sy; }
      }
    }
    // For each road, sample path segments and mark cells. If major, mark neighbors to widen.
    for(const r of roads){
      const levelVal = r.level === 'major' ? 3 : r.level === 'minor' ? 2 : 1;
      const path = r.path;
      for(let i=1; i<path.length; i++){
        const p0 = path[i-1];
        const p1 = path[i];
        bresenhamLine(p0.x, p0.y, p1.x, p1.y, (x,y) => {
          if(x<0||y<0||x>=w||y>=h) return;
          const idx = y*w + x;
          if(levelVal > roadMask[idx]) roadMask[idx] = levelVal;
          // Widen major roads by marking neighboring cells
          if(levelVal >= 3){
            for(let oy=-1; oy<=1; oy++){
              for(let ox=-1; ox<=1; ox++){
                const nx = x + ox;
                const ny = y + oy;
                if(nx<0||ny<0||nx>=w||ny>=h) continue;
                const ni = ny*w + nx;
                if(levelVal > roadMask[ni]) roadMask[ni] = levelVal;
              }
            }
          }
        });
      }
    }
    CURRENT = { ...CURRENT, height, slope, landMask, coastSegments, rivers, riverMask, cities, pois, factions, roads, detail, chaos: chaos, waterLevel, temperature, moisture: moistureArr, roadMask, opts };

    // Render layers
    renderBase();
    // Render overlay to the offscreen canvas at world scale for export
    renderOverlay(overlayCtx, 1);
    // Draw to main canvas
    draw();
  }

  // ---------- Geometry helpers
  function simplifyPath(path, tol){
    // Ramer–Douglas–Peucker for grid points
    if(path.length<=2) return path.slice();
    const sqTol = tol*tol;
    function sqDist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
    function sqSegDist(p,a,b){
      let x=a.x, y=a.y; let dx=b.x-x, dy=b.y-y; if(dx!==0||dy!==0){
        const t=((p.x-x)*dx+(p.y-y)*dy)/(dx*dx+dy*dy); if(t>1){x=b.x;y=b.y;} else if(t>0){x+=dx*t;y+=dy*t;}
      }
      dx=p.x-x; dy=p.y-y; return dx*dx+dy*dy;
    }
    function simplifyDP(points, first, last, sqTol, out){
      let maxSq= sqTol; let index=null;
      for(let i=first+1;i<last;i++){
        const sq = sqSegDist(points[i], points[first], points[last]);
        if(sq>maxSq){ index=i; maxSq=sq; }
      }
      if(index){ if(index-first>1) simplifyDP(points, first, index, sqTol, out); out.push(points[index]); if(last-index>1) simplifyDP(points, index, last, sqTol, out); }
    }
    const out=[path[0]]; simplifyDP(path,0,path.length-1,sqTol,out); out.push(path[path.length-1]); return out;
  }

  // ------------------------
  // MinHeap implementation for A* pathfinding. Stores objects with f-score and index.
  class MinHeap {
    constructor(){ this.heap = []; }
    push(node){
      this.heap.push(node);
      this._siftUp(this.heap.length - 1);
    }
    pop(){
      if(this.heap.length === 0) return null;
      const top = this.heap[0];
      const end = this.heap.pop();
      if(this.heap.length > 0){
        this.heap[0] = end;
        this._siftDown(0);
      }
      return top;
    }
    _siftUp(i){
      let parent;
      while(i > 0){
        parent = Math.floor((i - 1) / 2);
        if(this.heap[i].f < this.heap[parent].f){
          [this.heap[i], this.heap[parent]] = [this.heap[parent], this.heap[i]];
          i = parent;
        } else break;
      }
    }
    _siftDown(i){
      const length = this.heap.length;
      while(true){
        let left = i * 2 + 1;
        let right = left + 1;
        let smallest = i;
        if(left < length && this.heap[left].f < this.heap[smallest].f) smallest = left;
        if(right < length && this.heap[right].f < this.heap[smallest].f) smallest = right;
        if(smallest !== i){
          [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];
          i = smallest;
        } else break;
      }
    }
  }

  /**
   * Compute a terrain-aware path between two points using A* on a local grid.
   * Considers slope and water to determine movement cost. Returns an array of
   * points {x, y} representing the path from start to end inclusive. If no path
   * can be found, falls back to a straight line.
   */
  function astarPath(startX, startY, endX, endY, heightArr = CURRENT.height, slopeArr = CURRENT.slope, waterLvl = CURRENT.waterLevel){
    const w = worldW, h = worldH;
    // Round coordinates to nearest integer grid
    const sx = Math.round(clamp(startX, 0, w - 1));
    const sy = Math.round(clamp(startY, 0, h - 1));
    const ex = Math.round(clamp(endX, 0, w - 1));
    const ey = Math.round(clamp(endY, 0, h - 1));
    // If start or end are out of bounds, return straight line
    if(sx === ex && sy === ey){ return [{x: startX, y: startY}, {x: endX, y: endY}]; }
    // Define a local bounding box around the path for performance
    const margin = 40;
    let minX = Math.max(0, Math.min(sx, ex) - margin);
    let maxX = Math.min(w - 1, Math.max(sx, ex) + margin);
    let minY = Math.max(0, Math.min(sy, ey) - margin);
    let maxY = Math.min(h - 1, Math.max(sy, ey) + margin);
    const bw = maxX - minX + 1;
    const bh = maxY - minY + 1;
    const size = bw * bh;
    // Index in local grid to global x,y
    function localIndex(x, y){ return (y - minY) * bw + (x - minX); }
    function globalFromLocal(i){ const lx = i % bw + minX; const ly = Math.floor(i / bw) + minY; return {x: lx, y: ly}; }
    const startIdx = localIndex(sx, sy);
    const endIdx = localIndex(ex, ey);
    // Allocate gScore, fScore and cameFrom arrays
    const gScore = new Float32Array(size);
    const fScore = new Float32Array(size);
    const cameFrom = new Int32Array(size);
    const inOpen = new Uint8Array(size);
    const inClosed = new Uint8Array(size);
    for(let i=0;i<size;i++){ gScore[i] = Infinity; fScore[i] = Infinity; cameFrom[i] = -1; }
    gScore[startIdx] = 0;
    // Heuristic: Euclidean distance
    function heuristic(ix, iy){ return Math.hypot(ix - ex, iy - ey); }
    fScore[startIdx] = heuristic(sx, sy);
    const openHeap = new MinHeap();
    openHeap.push({idx: startIdx, f: fScore[startIdx]});
    inOpen[startIdx] = 1;
    // Predeclare neighbor offsets (8 directions)
    const dirs = [
      [1, 0], [-1, 0], [0, 1], [0, -1],
      [1, 1], [1, -1], [-1, 1], [-1, -1]
    ];
    while(true){
      const node = openHeap.pop();
      if(!node) break;
      const currentIdx = node.idx;
      if(inClosed[currentIdx]) continue;
      inOpen[currentIdx] = 0;
      // If reached goal, reconstruct path
      if(currentIdx === endIdx){
        const path = [];
        let ci = currentIdx;
        while(ci !== -1){ path.push(globalFromLocal(ci)); ci = cameFrom[ci]; }
        path.reverse();
        // Convert to {x,y} points
        return path.map(p => ({x: p.x, y: p.y}));
      }
      inClosed[currentIdx] = 1;
      const current = globalFromLocal(currentIdx);
      const cx = current.x; const cy = current.y;
      const currentG = gScore[currentIdx];
      for(const [dx, dy] of dirs){
        const nx = cx + dx;
        const ny = cy + dy;
        if(nx < minX || nx > maxX || ny < minY || ny > maxY) continue;
        const nIdx = localIndex(nx, ny);
        if(inClosed[nIdx]) continue;
        // Movement cost: base 1 + slope penalty + water penalty
        const globalIdx = ny * w + nx;
        const cellSlope = slopeArr ? slopeArr[globalIdx] : 0;
        const cellHeight = heightArr ? heightArr[globalIdx] : 0;
        let cost = 1 + cellSlope * 40;
        // If water cell, discourage crossing but allow with high cost
        if(cellHeight < waterLvl){ cost += 50; }
        // Diagonal moves cost more
        if(dx !== 0 && dy !== 0) cost *= 1.4;
        const tentativeG = currentG + cost;
        if(tentativeG < gScore[nIdx]){
          cameFrom[nIdx] = currentIdx;
          gScore[nIdx] = tentativeG;
          fScore[nIdx] = tentativeG + heuristic(nx, ny);
          if(!inOpen[nIdx]){
            openHeap.push({idx: nIdx, f: fScore[nIdx]});
            inOpen[nIdx] = 1;
          }
        }
      }
    }
    // Fallback: return a straight line if no path found
    return [ {x: startX, y: startY}, {x: endX, y: endY} ];
  }

  /**
   * Apply a gentle jitter to a path by offsetting intermediate points
   * perpendicular to their direction. This yields a more natural curvature
   * without appearing too sinusoidal. The amount of jitter decreases towards
   * the ends of the path.
   */
  function jitterPath(points, rnd, amplitude = 3){
    if(!points || points.length < 3) return points;
    const out = [points[0]];
    const n = points.length;
    for(let i=1;i<n-1;i++){
      const pPrev = points[i-1];
      const pCurr = points[i];
      const pNext = points[i+1];
      // Direction vector from prev to next
      const dx = pNext.x - pPrev.x;
      const dy = pNext.y - pPrev.y;
      const len = Math.hypot(dx, dy) || 1;
      // Perpendicular unit vector
      const ux = -dy / len;
      const uy = dx / len;
      // Weight jitter by distance from ends
      const t = i / (n - 1);
      const weight = Math.sin(Math.PI * t);
      const j = (rnd() - 0.5) * amplitude * weight;
      out.push({x: pCurr.x + ux * j, y: pCurr.y + uy * j});
    }
    out.push(points[n - 1]);
    return out;
  }

  /**
   * Apply a natural noise-based wobble to a polyline representing a road. Uses
   * fractional Brownian motion (fbm) noise to determine perpendicular offsets
   * based on the world coordinates of each point. The amplitude controls the
   * maximum deviation. The wobble tapers near the ends of the path to avoid
   * disturbing endpoints.
   *
   * @param {Array} points - Array of {x, y} points representing the polyline
   * @param {Object} noise - A noise generator with an fbm(x,y) method
   * @param {number} amplitude - Maximum perpendicular offset in world units
   * @returns {Array} New array of {x, y} points with applied noise offsets
   */
  function applyRoadNoise(points, noise, amplitude = 3){
    if(!noise || !points || points.length < 3) return points;
    const out = [points[0]];
    const n = points.length;
    for(let i=1; i<n-1; i++){
      const pPrev = points[i-1];
      const pCurr = points[i];
      const pNext = points[i+1];
      // Direction vector from prev to next
      const dx = pNext.x - pPrev.x;
      const dy = pNext.y - pPrev.y;
      const len = Math.hypot(dx, dy) || 1;
      // Perpendicular unit vector
      const ux = -dy / len;
      const uy = dx / len;
      // Weight the noise effect to taper at ends
      const t = i / (n - 1);
      const weight = Math.sin(Math.PI * t);
      // Sample 2D noise: fbm returns approx 0..1, center around 0
      const nVal = noise.fbm(pCurr.x * 0.02, pCurr.y * 0.02, 3, 2.0, 0.5) - 0.5;
      const offset = nVal * amplitude * weight;
      out.push({x: pCurr.x + ux * offset, y: pCurr.y + uy * offset});
    }
    out.push(points[n - 1]);
    return out;
  }
  function smoothPath(points){
    // Catmull-Rom to polyline sampling
    if(points.length<3) return points.slice();
    const out=[]; const s=8; // samples per segment
    for(let i=-1;i<points.length-2;i++){
      const p0=points[Math.max(i,0)], p1=points[i+1], p2=points[i+2], p3=points[Math.min(i+3, points.length-1)];
      for(let j=0;j<s;j++){
        const t=j/s; const t2=t*t, t3=t2*t;
        const x=0.5*((2*p1.x)+(-p0.x+p2.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*t2+(-p0.x+3*p1.x-3*p2.x+p3.x)*t3);
        const y=0.5*((2*p1.y)+(-p0.y+p2.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*t2+(-p0.y+3*p1.y-3*p2.y+p3.y)*t3);
        out.push({x,y});
      }
    }
    out.push(points[points.length-1]);
    return out;
  }
  function jitteredPath(x0,y0,x1,y1, rnd, landMask, w,h){
    const segs = Math.max(12, Math.min(80, Math.floor(Math.hypot(x1-x0,y1-y0)/12)));
    const pts=[];
    for(let i=0;i<=segs;i++){
      const t=i/segs; let x=lerp(x0,x1,t), y=lerp(y0,y1,t);
      // Perpendicular jitter for organic feel, avoid water bias a bit
      const nx=-(y1-y0), ny=(x1-x0); const nlen=Math.hypot(nx,ny)||1; const ux=nx/nlen, uy=ny/nlen;
      const jitter = (rnd()-0.5)*8*(1-(Math.abs(0.5-t)*1.2));
      x += ux*jitter; y += uy*jitter;
      // Slight attraction to land if near coast
      const ix=Math.floor(clamp(x,1,w-2)), iy=Math.floor(clamp(y,1,h-2));
      const ixy=iy*w+ix; if(!landMask[ixy]){ x=(x+lerp(x0,x1,t))/2; y=(y+lerp(y0,y1,t))/2; }
      pts.push({x,y});
    }
    return pts;
  }
  function computeBridges(path, riverMask, w,h){
    const bridges=[]; let inRiver=false;
    for(let i=0;i<path.length;i++){
      const p=path[i]; const x=Math.floor(p.x), y=Math.floor(p.y);
      if(x<0||y<0||x>=w||y>=h) continue;
      const r = riverMask[y*w+x]===1;
      if(r && !inRiver){ inRiver=true; bridges.push({x:p.x,y:p.y}); }
      if(!r && inRiver){ inRiver=false; }
    }
    return bridges;
  }
  function isNearMask(x,y,mask,w,h,dist){
    const d=dist|0; for(let ry=-d;ry<=d;ry++) for(let rx=-d;rx<=d;rx++){
      const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; if(mask[ny*w+nx]) return true; }
    return false;
  }
  function hasNeighborTaken(taken,w,h,x,y,r){
    for(let ry=-r;ry<=r;ry++) for(let rx=-r;rx<=r;rx++){
      const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; if(taken[ny*w+nx]) return true; }
    return false;
  }
  function markTaken(taken,w,h,x,y,r){
    for(let ry=-r;ry<=r;ry++) for(let rx=-r;rx<=r;rx++){
      const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; taken[ny*w+nx]=1; }
  }
  function computeMST(nodes, dist){
    // Prim's
    if(nodes.length<=1) return [];
    const inTree = new Set([0]);
    const edges=[];
    while(inTree.size < nodes.length){
      let best=null, bestI=-1, bestJ=-1, bestD=1e9;
      for(const i of inTree){
        for(let j=0;j<nodes.length;j++) if(!inTree.has(j)){
          const d = dist(nodes[i], nodes[j]); if(d<bestD){ bestD=d; bestI=i; bestJ=j; best=[nodes[i], nodes[j]]; }
        }
      }
      edges.push(best);
      inTree.add(bestJ);
    }
    return edges;
  }

  // ---------- Rendering
  function renderBase(){
    const {height, landMask, coastSegments, waterLevel, rivers, riverMask, roads, temperature, moisture} = CURRENT;
    const w=worldW, h=worldH; const ctx=baseCtx; ctx.clearRect(0,0,w,h);

    // Step color fill with biome-based colours. Compute colour per pixel based on
    // elevation, temperature, and moisture. Water cells use the ocean palette; land
    // cells are coloured by biome.
    const img = ctx.createImageData(w,h);
    const data = img.data;
    // Define base colours for each biome. Colours will be lightened based on elevation.
    const baseCols = {
      desert: '#e0c48a',
      savanna: '#c1a15e',
      grassland: '#91aa57',
      deciduous: '#6f8440',
      rainforest: '#3a6c36',
      taiga: '#6d816c',
      tundra: '#9aa99f',
      mountain: '#8a8a8a',
      snow: '#e4e4e4'
    };
    for(let i=0;i<height.length;i++){
      const z = height[i];
      let r=0,g=0,b=0;
      if(z < waterLevel){
        // Ocean palette: use step colours from OceanSteps
        const t = clamp((z / (waterLevel + 1e-6)) * OceanSteps.length, 0, OceanSteps.length - 1);
        const col = hexToRgb(OceanSteps[Math.floor(t)]);
        r = col.r; g = col.g; b = col.b;
      } else {
        const rel = (z - waterLevel) / (1 - waterLevel + 1e-6);
        const temp = temperature[i];
        const moist = moisture[i];
        let biome;
        // Classify mountains and snow based on elevation relative
        if(rel > 0.78){
          biome = 'snow';
        } else if(rel > 0.65){
          biome = 'mountain';
        } else {
          // Determine biome based on climate zones
          if(temp < 0.3){
            biome = moist > 0.5 ? 'taiga' : 'tundra';
          } else if(temp < 0.6){
            if(moist > 0.7) biome = 'rainforest';
            else if(moist > 0.4) biome = 'deciduous';
            else biome = 'grassland';
          } else {
            if(moist > 0.7) biome = 'rainforest';
            else if(moist > 0.4) biome = 'savanna';
            else biome = 'desert';
          }
        }
        let baseColHex = baseCols[biome] || '#88aa55';
        // Lighten the base colour based on elevation to give depth variation
        const lightFactor = rel * 0.4;
        const adjustedHex = lightenColor(baseColHex, lightFactor);
        const col = hexToRgb(adjustedHex);
        r = col.r; g = col.g; b = col.b;
      }
      // Apply road overlay: if this pixel is part of a road, replace with the road colour by level. 100% opaque.
      if(CURRENT.roadMask){
        const level = CURRENT.roadMask[i];
        if(level > 0){
          // Determine colour for each road level: major, minor, trail.
          if(!renderBase.cachedRoadCols){
            // Cache road colours in rgb to avoid repeated conversion
            renderBase.cachedRoadCols = {};
          }
          let colArr = renderBase.cachedRoadCols;
          // Use base RoadColor for major roads
          if(!colArr.major){ colArr.major = hexToRgb(RoadColor); }
          if(!colArr.minor){ colArr.minor = hexToRgb(lightenColor(RoadColor, 0.25)); }
          if(!colArr.trail){ colArr.trail = hexToRgb(lightenColor(RoadColor, 0.45)); }
          let rc;
          if(level === 3) rc = colArr.major;
          else if(level === 2) rc = colArr.minor;
          else rc = colArr.trail;
          r = rc.r;
          g = rc.g;
          b = rc.b;
        }
      }
      data[i*4+0] = r;
      data[i*4+1] = g;
      data[i*4+2] = b;
      data[i*4+3] = 255;
    }
    ctx.putImageData(img, 0, 0);

    // Rivers on top (variable width)
    ctx.save();
    ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.strokeStyle=RiverColor;
    for(const river of rivers){
      ctx.beginPath();
      for(let i=0;i<river.length;i++){
        const p=river[i]; const t=i/river.length;
        // Adjust river width by user-defined factor (default 1.0)
        const widthFactor = CURRENT.opts && CURRENT.opts.riverWidth ? CURRENT.opts.riverWidth : 1.0;
        const wv = widthFactor * (1 + t*2.2); // widen downstream
        if(i===0){ ctx.moveTo(p.x,p.y); ctx.lineWidth=wv; }
        else { ctx.lineTo(p.x,p.y); ctx.lineWidth=wv; }
      }
      ctx.stroke();
    }
    ctx.restore();

    // Coast outline: thin dark line between land and water. Offset by 0.5 to
    // align with pixel boundaries and avoid antialiasing.
    ctx.save();
    ctx.strokeStyle = '#0a0c10';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.9;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    for(const seg of coastSegments){
      ctx.beginPath();
      ctx.moveTo(seg[0].x + 0.5, seg[0].y + 0.5);
      for(let i=1;i<seg.length;i++){
        ctx.lineTo(seg[i].x + 0.5, seg[i].y + 0.5);
      }
      ctx.stroke();
    }
    ctx.restore();

    // Draw multi-tile city footprints directly on the terrain. Each tile occupied by
    // a city is coloured using a lightened version of its faction colour. This
    // provides visual differentiation without adding separate banners. We also
    // draw a subtle inner outline to delineate adjacent city tiles.
    if(CURRENT.cities && CURRENT.cities.length){
      ctx.save();
      for(const c of CURRENT.cities){
        const baseColour = CURRENT.factions[c.faction]?.color || '#aaaaaa';
        const fillCol = lightenColor(baseColour, 0.25);
        const strokeCol = darkenColor(baseColour, 0.3);
        ctx.fillStyle = fillCol;
        ctx.strokeStyle = strokeCol;
        // Draw each tile. Fill the tile only; inner outlines are removed to avoid antialiasing.
        for(const t of c.tiles){
          ctx.fillRect(t.x, t.y, 1, 1);
        }
      }
      ctx.restore();
    }

    // We no longer draw roads here as vector shapes; instead roads are baked into the
    // terrain via the roadMask above.
  }

  // Render overlay features (roads, POIs, and city labels) to a given context.
  // This function accepts an optional rendering context and a zoom level. When called
  // without arguments, it draws onto the offscreen overlay canvas at world scale (zoom=1).
  // When drawing to the main canvas, pass in the current `ctx` and the current `SCALE` so
  // labels and icons maintain a consistent size on screen.
  function renderOverlay(targetCtx = overlayCtx, zoom = 1){
    const ctx = targetCtx;
    const {cities, roads, factions, pois} = CURRENT;
    // If we're drawing to the offscreen overlay, clear it first.
    if (ctx === overlayCtx) {
      ctx.clearRect(0, 0, worldW, worldH);
    }
    // Compute scale factors: using 1/zoom keeps elements constant size on screen.
    const scaleFactor = 1 / zoom;
    const clampedScale = clamp(scaleFactor, 0.4, 3.0);
    // Roads are now painted directly onto the terrain in renderBase. Skip drawing them here.
    // Draw points of interest
    for(const p of pois){
      drawPOI(ctx, p, scaleFactor, clampedScale);
    }
    // Draw city icons and labels
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for(const c of cities){
      const isHover = CURRENT.hoverCity === c.id;
      // Determine font size based on city type
      const baseFont = c.type==='village' ? 10 : c.type==='town' ? 12 : c.type==='city' ? 14 : c.type==='capital' ? 16 : 12;
      const fontSize = baseFont * clampedScale * (isHover ? 1.2 : 1.0);
      ctx.font = `bold ${fontSize}px/1.2 'Palatino Linotype', 'Book Antiqua', Palatino, 'Georgia', serif`;
      const label = c.name;
      // Draw city dot
      const baseRadius = c.type==='village' ? 2.2 : 3.0;
      const radius = baseRadius * clampedScale * (isHover ? 1.4 : 1.0);
      ctx.fillStyle = c.type==='village' ? '#dcdcdc' : '#f4e4a4';
      ctx.strokeStyle = '#0008';
      ctx.beginPath(); ctx.arc(c.x, c.y - 4 * clampedScale, radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      // Label colour depending on city type and hover state
      let textCol;
      if(c.type === 'village') textCol = isHover ? '#d4dce6' : '#bfc8d6';
      else if(c.type === 'city' || c.type === 'capital') textCol = isHover ? '#ff8585' : '#ff5252';
      else textCol = isHover ? '#f0d8a0' : '#e8e0c0';
      // Outline colour: dark unsaturated brown
      const outlineColor = '#3b2d1f';
      const lineW = 0.8 * clampedScale * (isHover ? 1.2 : 1.0);
      ctx.strokeStyle = outlineColor;
      ctx.lineWidth = lineW;
      ctx.strokeText(label, c.x, c.y - (20 * clampedScale));
      ctx.fillStyle = textCol;
      ctx.fillText(label, c.x, c.y - (20 * clampedScale));

      // If hovering over this city, draw a crisp black outline around its shape.
      if(isHover && c.tiles){
        ctx.save();
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.beginPath();
        // For each tile, draw border segments where neighbouring tile is not part of the city
        const tileSet = new Set(c.tiles.map(t => t.y * worldW + t.x));
        for(const t of c.tiles){
          const x = t.x;
          const y = t.y;
          // Left edge
          if(!tileSet.has(y * worldW + (x - 1))){
            ctx.moveTo(x + 0.0, y + 0.0);
            ctx.lineTo(x + 0.0, y + 1.0);
          }
          // Right edge
          if(!tileSet.has(y * worldW + (x + 1))){
            ctx.moveTo(x + 1.0, y + 0.0);
            ctx.lineTo(x + 1.0, y + 1.0);
          }
          // Top edge
          if(!tileSet.has((y - 1) * worldW + x)){
            ctx.moveTo(x + 0.0, y + 0.0);
            ctx.lineTo(x + 1.0, y + 0.0);
          }
          // Bottom edge
          if(!tileSet.has((y + 1) * worldW + x)){
            ctx.moveTo(x + 0.0, y + 1.0);
            ctx.lineTo(x + 1.0, y + 1.0);
          }
        }
        ctx.stroke();
        ctx.restore();
      }
    }
    ctx.restore();
  }

  function draw(){
    // Composite the base and overlay directly onto the main canvas. We re-render the overlay
    // at the current zoom level to maintain crisp text and icon sizes.
    ctx.save();
    ctx.clearRect(0, 0, W, H);
    // Apply world-to-screen transform
    ctx.setTransform(SCALE, 0, 0, SCALE, panX, panY);
    // Draw terrain (base) without antialiasing for crisp pixel edges
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(baseOff, 0, 0);
    // Draw overlay (roads, POIs, cities) directly onto the main canvas at current zoom
    // Vector drawings are inherently crisp; no need to toggle imageSmoothingEnabled here.
    renderOverlay(ctx, SCALE);
    // Restore to default coordinate system
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.restore();
  }

  // ---------- POI Drawing
  // Draw a point of interest (POI) icon and label on the provided context. Accepts
  // optional scale parameters so the size can remain consistent across zoom levels.
  function drawPOI(ctx, poi, scaleFactor = 1 / SCALE, clampedScale = clamp(scaleFactor, 0.4, 3.0)){
    const {x, y, type, name} = poi;
    ctx.save();
    const isHover = CURRENT.hoverPoi === poi.id;
    // Determine sizes for the icon and stroke based on scale and hover state
    const strokeWidth = 1.0 * clampedScale * (isHover ? 1.4 : 1.0);
    const sizeUnit = 4 * clampedScale * (isHover ? 1.4 : 1.0);
    ctx.strokeStyle = isHover ? '#ffcc66' : '#0009';
    ctx.fillStyle = isHover ? '#ffe0b0' : '#d1d5db';
    switch(type){
      case 'ruins':
        ctx.beginPath();
        ctx.moveTo(x - sizeUnit, y - sizeUnit/2);
        ctx.lineTo(x - sizeUnit/4, y - sizeUnit*2);
        ctx.lineTo(x + sizeUnit/4, y - sizeUnit*2);
        ctx.lineTo(x + sizeUnit, y - sizeUnit/2);
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
        break;
      case 'tower':
        ctx.beginPath();
        ctx.rect(x - sizeUnit/2, y - sizeUnit*2, sizeUnit, sizeUnit*1.5);
        ctx.moveTo(x - sizeUnit/2, y - sizeUnit*2);
        ctx.lineTo(x + sizeUnit/2, y - sizeUnit*2);
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
        break;
      case 'shrine':
        ctx.beginPath();
        ctx.arc(x, y - sizeUnit*1.5, sizeUnit*0.6, 0, Math.PI * 2);
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
        break;
      case 'crypt':
        ctx.beginPath();
        ctx.moveTo(x - sizeUnit, y - sizeUnit/2);
        ctx.lineTo(x, y - sizeUnit*2);
        ctx.lineTo(x + sizeUnit, y - sizeUnit/2);
        ctx.closePath();
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
        break;
    }
    // Draw POI label with dark outline
    const fontSize = 10 * clampedScale * (isHover ? 1.2 : 1.0);
    ctx.font = `${fontSize}px 'Palatino Linotype', 'Book Antiqua', Palatino, 'Georgia', serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    // Outline colour and line width
    const outlineColor = '#3b2d1f';
    const lineW = 0.7 * clampedScale * (isHover ? 1.2 : 1.0);
    ctx.strokeStyle = outlineColor;
    ctx.lineWidth = lineW;
    ctx.strokeText(name, x, y - sizeUnit * 3);
    ctx.fillStyle = isHover ? '#ffe0b0' : '#9aa4b2';
    ctx.fillText(name, x, y - sizeUnit * 3);
    ctx.restore();
  }

  // ---------- Hit Testing for tooltip & clicks
  function hitTest(wx, wy){
    const {cities, pois} = CURRENT;
    // Cities first
    for(let i=0;i<cities.length;i++){
      const c=cities[i]; const dx=wx-c.x, dy=wy-c.y; if(dx*dx+dy*dy< 10*10){
        return {kind:'city', data:c, tooltip: `<b>${escapeHtml(c.name)}</b><br>${c.type} • pop ${c.pop.toLocaleString()}<br>Faction: ${escapeHtml(CURRENT.factions[c.faction]?.name||'—')}`};
      }
    }
    // POIs smaller radius
    for(let i=0;i<pois.length;i++){
      const p=pois[i]; const dx=wx-p.x, dy=wy-p.y; if(dx*dx+dy*dy< 8*8){
        return {kind:'poi', data:p, tooltip: `${escapeHtml(p.name)} (${p.type})`};
      }
    }
    // If no city or POI was hit, return detailed pixel information if within bounds
    const xi = Math.floor(wx);
    const yi = Math.floor(wy);
    const w = worldW, h = worldH;
    if(xi >= 0 && yi >= 0 && xi < w && yi < h){
      const idx = yi * w + xi;
      const {height, waterLevel, temperature, moisture, slope, roadMask, cityTileMap, cities, factions} = CURRENT;
      const z = height[idx];
      // Compute relative elevation (0-1 above water)
      const rel = z < waterLevel ? 0 : (z - waterLevel) / (1 - waterLevel + 1e-6);
      const temp = temperature[idx];
      const moist = moisture[idx];
      const slp = slope[idx];
      // Determine biome type using the same thresholds as renderBase
      let biome;
      if(z < waterLevel){
        biome = 'ocean';
      } else if(rel > 0.78){
        biome = 'snow';
      } else if(rel > 0.65){
        biome = 'mountain';
      } else {
        if(temp < 0.3){
          biome = moist > 0.5 ? 'taiga' : 'tundra';
        } else if(temp < 0.6){
          if(moist > 0.7) biome = 'rainforest';
          else if(moist > 0.4) biome = 'deciduous';
          else biome = 'grassland';
        } else {
          if(moist > 0.7) biome = 'rainforest';
          else if(moist > 0.4) biome = 'savanna';
          else biome = 'desert';
        }
      }
      // Check if this pixel belongs to a city
      let occupant = null;
      if(cityTileMap && cityTileMap[idx] !== undefined && cityTileMap[idx] >= 0){
        const cid = cityTileMap[idx];
        const city = cities[cid];
        if(city){ occupant = city.name; }
      }
      // Check if this pixel is a road
      let roadInfo = null;
      if(roadMask && roadMask[idx] > 0){
        roadInfo = roadMask[idx] === 3 ? 'major road' : roadMask[idx] === 2 ? 'minor road' : 'trail';
      }
      // Convert relative elevation to metres: assume max elevation is ~3000m and water level 0
      const elevation = Math.round(rel * 3000);
      // Convert temperature (0..1) to degrees Celsius: approximate -20°C to 40°C
      const tempC = Math.round((temp * 60) - 20);
      const humPct = Math.round(moist * 100);
      const slopePct = Math.round(slp * 100);
      let tip = `<b>Tile (${xi},${yi})</b><br>`;
      if(occupant) tip += `<strong>City:</strong> ${escapeHtml(occupant)}<br>`;
      if(roadInfo) tip += `<strong>Road:</strong> ${roadInfo}<br>`;
      tip += `<strong>Biome:</strong> ${biome}<br>`;
      tip += `<strong>Elevation:</strong> ${elevation}m<br>`;
      tip += `<strong>Temp:</strong> ${tempC}°C<br>`;
      tip += `<strong>Moisture:</strong> ${humPct}%<br>`;
      tip += `<strong>Slope:</strong> ${slopePct}%`;
      return {kind:'tile', data:{x:xi,y:yi}, tooltip: tip};
    }
    return null;
  }

  // ---------- City Panel + Minimap
  function openCityPanel(city){
    // Populate the old panel for compatibility (hidden), but primarily update the new city preview overlay
    panelTitle.textContent = city.name;
    panelType.textContent = city.type;
    panelFaction.textContent = CURRENT.factions[city.faction]?.name || '—';
    panelPop.textContent = city.pop.toLocaleString();
    panelPros.textContent = city.prosperity;
    panelDesc.textContent = describeCity(city);
    // Hide the old side panel; we'll use the cityPreview overlay instead
    panel.style.display = 'none';
    // Show the city preview overlay and populate its contents
    if(cityPreview){
      cityPreview.style.display = 'block';
      // Build info content
      const fName = CURRENT.factions[city.faction]?.name || '—';
      previewInfo.innerHTML = `
        <div style="font-weight:bold;font-size:16px;margin-bottom:4px;">${escapeHtml(city.name)}</div>
        <div><strong>Tipo:</strong> ${escapeHtml(city.type)}</div>
        <div><strong>Facção:</strong> ${escapeHtml(fName)}</div>
        <div><strong>População:</strong> ${city.pop.toLocaleString()}</div>
        <div><strong>Prosperidade:</strong> ${escapeHtml(city.prosperity)}</div>
        <div style="margin-top:6px;">${escapeHtml(describeCity(city))}</div>
      `;
      // Draw the minimap into previewMini
      drawCityMini(city, previewMini);
    }
  }

  function drawCityMini(city, targetCanvas = cityMini){
    // Determine target canvas dimensions based on its client size and device pixel ratio
    const dpr = DPI();
    const w = targetCanvas.clientWidth * dpr;
    const h = targetCanvas.clientHeight * dpr;
    targetCanvas.width = w;
    targetCanvas.height = h;
    const c = targetCanvas.getContext('2d');
    c.clearRect(0, 0, w, h);
    c.fillStyle = '#0b0e14';
    c.fillRect(0, 0, w, h);

    // Use a per-city RNG for layout variety
    const rnd = randFromSeed(CURRENT.seed + '|city|' + city.id);
    c.save();
    // Center the drawing and apply a uniform scale so that the map fits within the canvas regardless of its aspect ratio.
    c.translate(w/2, h/2);
    const scale = Math.min(w, h) / 200; // 200 is an arbitrary base size to normalise city features
    c.scale(scale, scale);

    // Road styles
    c.lineCap='round'; c.lineJoin='round';

    if(city.type==='village'){
      // organic branching lanes
      for(let k=0;k<6;k++){
        const ang = rnd()*Math.PI*2; let len = 40 + rnd()*30; let x=0,y=0; c.beginPath(); c.moveTo(0,0);
        while(len>0){ x+=Math.cos(ang+(rnd()-0.5)*0.4)*6; y+=Math.sin(ang+(rnd()-0.5)*0.4)*6; c.lineTo(x,y); len-=6; }
        c.strokeStyle='#aa8955'; c.lineWidth=2.2; c.stroke();
      }
      drawHouses(c, rnd, 28, 38, 2.5);
    } else if(city.type==='town'){
      // grid-like
      c.strokeStyle='#b49661'; c.lineWidth=2.4;
      for(let i=-3;i<=3;i++){
        c.beginPath(); c.moveTo(-70,i*20); c.lineTo(70,i*20); c.stroke();
        c.beginPath(); c.moveTo(i*20,-70); c.lineTo(i*20,70); c.stroke();
      }
      drawBlocks(c, rnd, 18, 16);
    } else if(city.type==='city' || city.type==='capital'){
      // radial ring roads
      const rings = city.type==='capital'? 4:3; const spokes = 8+Math.floor(rnd()*4);
      c.strokeStyle='#bfa070';
      for(let r=1; r<=rings; r++){ c.beginPath(); c.arc(0,0, r*25, 0, Math.PI*2); c.lineWidth= city.type==='capital'? 3.2:2.6; c.stroke(); }
      for(let s=0;s<spokes;s++){ const ang=s*(Math.PI*2/spokes); c.beginPath(); c.moveTo(0,0); c.lineTo(Math.cos(ang)*rings*25, Math.sin(ang)*rings*25); c.lineWidth=2.4; c.stroke(); }
      drawBlocksRadial(c, rnd, rings, spokes);
    } else if(city.type==='port'){
      // harbor area
      c.fillStyle='#0b3a5a'; c.fillRect(-w/2,-h/2, w/2+20, h);
      c.strokeStyle='#b49661'; c.lineWidth=2.4; c.beginPath(); c.moveTo(0,-h/2+14); c.lineTo(0,h/2-14); c.stroke();
      for(let d=-3; d<=3; d++){
        c.beginPath(); c.moveTo(0, d*30); c.lineTo(70, d*30 + (rnd()-0.5)*10); c.stroke();
      }
      drawDocks(c, rnd);
    }

    c.restore();
  }
  function drawHouses(c, rnd, countA, countB, size){
    c.fillStyle='#d4cab5';
    for(let i=0;i<countA;i++){
      const x=-80 + rnd()*160, y=-80+rnd()*160; if(Math.hypot(x,y)>90) continue; c.fillRect(x,y, size+ rnd()*3, size + rnd()*3);
    }
    for(let i=0;i<countB;i++){
      const ang = rnd()*Math.PI*2; const r= 30 + rnd()*60; const x=Math.cos(ang)*r, y=Math.sin(ang)*r; c.fillRect(x,y, size+ rnd()*3, size + rnd()*3);
    }
  }
  function drawBlocks(c, rnd, rows, cols){
    c.fillStyle='#d4cab5';
    for(let i=0;i<rows;i++) for(let j=0;j<cols;j++){
      const x=-70 + j*9 + (rnd()-0.5)*2, y=-70 + i*9 + (rnd()-0.5)*2; if((i%3===0)||(j%3===0)) continue; c.fillRect(x,y,6,6);
    }
  }
  function drawBlocksRadial(c, rnd, rings, spokes){
    c.fillStyle='#d4cab5';
    for(let r=1;r<=rings;r++){
      for(let s=0;s<spokes;s++){
        const ang = s*(Math.PI*2/spokes) + (rnd()-0.5)*0.1;
        const rad = r*25 + 5 + (rnd()-0.5)*3; const x=Math.cos(ang)*rad, y=Math.sin(ang)*rad;
        c.fillRect(x,y, 6+rnd()*4, 6+rnd()*4);
      }
    }
  }
  function drawDocks(c, rnd){
    c.fillStyle='#d4cab5';
    for(let i=0;i<30;i++){
      const x = 10 + rnd()*80, y = -60 + rnd()*120; c.fillRect(x,y, 6, 6);
    }
  }

  // ---------- Names & Text
  function chooseType(rnd){
    const r=rnd(); if(r<0.5) return 'village'; if(r<0.78) return 'town'; if(r<0.95) return 'city'; if(r<0.98) return 'capital'; return 'town';
  }
  function makePlaceName(rnd, type){
    // Very lightweight namegen with a fantasy vibe
    const syll = ["ka","ra","bel","dor","an","mar","tul","ver","lin","os","is","ur","thal","ren","mor","val","ira","oth","brin","cor","eld","fen","gal","har","ion","jor","kel","lor","mir"];
    const parts = 2 + (rnd()<0.35?1:0);
    let name=''; for(let i=0;i<parts;i++){ name+= syll[Math.floor(rnd()*syll.length)]; }
    name = name.charAt(0).toUpperCase()+name.slice(1);
    if(type==='port' && rnd()<0.6) name = name + ' Bay';
    if(type==='capital' && rnd()<0.6) name = 'New ' + name;
    return name;
  }
  function makeFactionName(rnd){
    const p1=['Kingdom','Duchy','Realm','League','March','Barony','Confederacy'];
    const p2=['Alder','Cinder','Iron','Silver','Golden','Storm','Moon','Wolf','Raven','Ash'];
    const p3=['vale','reach','keep','fall','hold','mere','field','watch','crest','bar'];
    const name = p1[Math.floor(rnd()*p1.length)] + ' of ' + p2[Math.floor(rnd()*p2.length)] + p3[Math.floor(rnd()*p3.length)];
    return name;
  }
  function makePOIName(rnd,type){
    const base = {
      ruins:['Old Ruins','Fallen Halls','Broken Gate','Shattered Forum'],
      tower:['Wizard Tower','Watch Spire','Astral Tower','Ivory Spire'],
      shrine:['Moon Shrine','Sun Shrine','Ancient Shrine','Grove Shrine'],
      crypt:['Forgotten Crypt','Black Crypt','Bone Vault','Silent Tomb']
    }[type] || ['Ancient Site'];
    return base[Math.floor(rnd()*base.length)];
  }

  function describeCity(c){
    const f = CURRENT.factions[c.faction]?.name || '—';
    const flavor = {
      village: 'A quiet hamlet with scattered cottages and a small market square.',
      town: 'A bustling market town with tidy streets and watch towers.',
      city: 'A dense, lively city with multiple districts and ring roads.',
      capital: 'The grand capital, seat of power and culture across the realm.',
      port: 'A rugged harbor with docks, warehouses and salty air.'
    }[c.type];
    // Determine climate and biome at the city location
    const idx = c.y * worldW + c.x;
    const z = CURRENT.height[idx];
    const waterLevel = CURRENT.waterLevel;
    const rel = (z - waterLevel) / (1 - waterLevel + 1e-6);
    const temp = CURRENT.temperature ? CURRENT.temperature[idx] : 0.5;
    const moist = CURRENT.moisture ? CURRENT.moisture[idx] : 0.5;
    function classifyClimate(t){
      if(t < 0.3) return 'frio';
      if(t < 0.6) return 'temperado';
      return 'quente';
    }
    function classifyBiome(rel, t, m){
      if(rel > 0.78) return 'gélido';
      if(rel > 0.65) return 'montanhoso';
      if(t < 0.3){ return m > 0.5 ? 'taiga' : 'tundra'; }
      if(t < 0.6){
        if(m > 0.7) return 'floresta densa';
        if(m > 0.4) return 'floresta temperada';
        return 'pradaria';
      }
      // hot
      if(m > 0.7) return 'floresta tropical';
      if(m > 0.4) return 'savana';
      return 'deserto';
    }
    const climate = classifyClimate(temp);
    const biome = classifyBiome(rel, temp, moist);
    return `${flavor} Alinhada à ${f}. Prosperidade: ${c.prosperity}. Clima: ${climate}. Bioma: ${biome}.`;
  }

  function isNearAnyCity(cities,x,y,dist){
    for(const c of cities){ if(Math.hypot(c.x-x,c.y-y)<dist) return true; } return false;
  }

  // ---------- UI handlers
  document.getElementById('gen').addEventListener('click', ()=>{
    const seed = document.getElementById('seed').value || 'seed';
    const cities = parseInt(document.getElementById('cities').value||120,10);
    const rivers = parseInt(document.getElementById('rivers').value||10,10);
    const water = parseInt(document.getElementById('water').value||45,10);
    const chaos = parseInt(document.getElementById('chaos').value||45,10)/100;
    const detail = document.getElementById('detail').value;
    // Additional user-configurable settings
    const mountains = parseInt(document.getElementById('mountains').value || 30, 10);
    const factions = parseInt(document.getElementById('factions').value || 0, 10);
    // Terrain resolution factor (float). Controls world pixel density.
    const terrainRes = parseFloat(document.getElementById('terrainRes')?.value || '1.0');
    const colors = {
      ocean: document.getElementById('colorOcean').value,
      land: document.getElementById('colorLand').value,
      hills: document.getElementById('colorHills').value,
      mountains: document.getElementById('colorMountains').value,
      river: document.getElementById('colorRiver').value,
      road: document.getElementById('colorRoad').value
    };
    // Read additional tweak parameters
    const slopeLimit = parseFloat(document.getElementById('slopeLimit')?.value || '15');
    const moistureScale = parseFloat(document.getElementById('moistureScale')?.value || '1.0');
    const tempScale = parseFloat(document.getElementById('tempScale')?.value || '1.0');
    const biomeDiv = parseFloat(document.getElementById('biomeDiv')?.value || '1.0');
    const citySizeVar = parseFloat(document.getElementById('citySizeVar')?.value || '0.0');
    const cityCluster = parseFloat(document.getElementById('cityCluster')?.value || '1.0');
    const roadDensity = parseFloat(document.getElementById('roadDensity')?.value || '0.35');
    const riverWidth = parseFloat(document.getElementById('riverWidth')?.value || '1.0');
    // Read new tweak parameters
    const peakFreq = parseFloat(document.getElementById('peakFreq')?.value || '1.0');
    const citySpacing = parseFloat(document.getElementById('citySpacing')?.value || '1.0');
    const roadCurvature = parseFloat(document.getElementById('roadCurvature')?.value || '1.0');
    generate({
      seed,
      cities,
      rivers,
      waterPct: water,
      chaos,
      detail,
      mountains,
      factions,
      colors,
      terrainRes,
      slopeLimit,
      moistureScale,
      tempScale,
      biomeDiv,
      citySizeVar,
      cityCluster,
      roadDensity,
      riverWidth
      ,peakFreq
      ,citySpacing
      ,roadCurvature
    });
  });
  document.getElementById('export').addEventListener('click', ()=>{
    exportPNG();
  });

  // Display slider values in the UI
  function updateSliderDisplay(id, val, suffix=''){
    const el = document.getElementById(id);
    if(el) el.textContent = val + suffix;
  }
  // Attach listeners to range inputs to update display values
  const waterSlider = document.getElementById('water');
  const waterValEl = document.getElementById('waterVal');
  if(waterSlider && waterValEl){
    waterSlider.addEventListener('input', ()=>{ updateSliderDisplay('waterVal', waterSlider.value, '%'); });
    // Initialize display
    updateSliderDisplay('waterVal', waterSlider.value, '%');
  }
  const chaosSlider = document.getElementById('chaos');
  if(chaosSlider){
    chaosSlider.addEventListener('input', ()=>{ updateSliderDisplay('chaosVal', chaosSlider.value); });
    updateSliderDisplay('chaosVal', chaosSlider.value);
  }
  const mountainsSlider = document.getElementById('mountains');
  if(mountainsSlider){
    mountainsSlider.addEventListener('input', ()=>{ updateSliderDisplay('mountainsVal', mountainsSlider.value); });
    updateSliderDisplay('mountainsVal', mountainsSlider.value);
  }

  const terrainResSlider = document.getElementById('terrainRes');
  if(terrainResSlider){
    terrainResSlider.addEventListener('input', ()=>{
      updateSliderDisplay('terrainResVal', parseFloat(terrainResSlider.value).toFixed(1));
    });
    updateSliderDisplay('terrainResVal', parseFloat(terrainResSlider.value).toFixed(1));
  }

  // ---------- Custom colour palette management ----------
  // This palette controls the colours used for land and influences hills and mountain colours.
  let customPalette = [];
  function renderColorList(){
    const container = document.getElementById('colorList');
    if(!container) return;
    container.innerHTML = '';
    customPalette.forEach((col, idx) => {
      const row = document.createElement('div');
      row.style.display='flex'; row.style.gap='6px'; row.style.alignItems='center';
      const inp = document.createElement('input'); inp.type='color'; inp.value=col;
      inp.addEventListener('input', ()=>{
        customPalette[idx] = inp.value;
        updatePalette();
      });
      const btn = document.createElement('button'); btn.textContent='×'; btn.className='btn'; btn.style.flex='0 0 auto'; btn.style.padding='4px 8px';
      btn.addEventListener('click', ()=>{
        customPalette.splice(idx,1);
        renderColorList();
        updatePalette();
      });
      row.appendChild(inp);
      row.appendChild(btn);
      container.appendChild(row);
    });
  }
  // Deferred palette update to avoid triggering expensive re-renders for each drag event.
  let paletteUpdateTimeout;
  function updatePaletteImmediate(){
    if(customPalette && customPalette.length>0){
      MapColors = customPalette.slice();
      renderBase();
      draw();
    }
  }
  function updatePalette(){
    clearTimeout(paletteUpdateTimeout);
    paletteUpdateTimeout = setTimeout(updatePaletteImmediate, 200);
  }
  // Set up add/remove controls once DOM is ready
  window.addEventListener('load', () => {
    const addBtn = document.getElementById('addColor');
    if(addBtn){
      addBtn.addEventListener('click', ()=>{
        customPalette.push('#6b9b59');
        renderColorList();
        updatePalette();
      });
    }
    // Initialise palette with a few colours matching the default land colours
    customPalette = ['#8fb065','#6b9b59','#3e6f45'];
    renderColorList();
    updatePalette();

    // Tabbed settings interface: activate corresponding content panel when a tab is clicked
    const tabButtons = document.querySelectorAll('.tabBtn');
    const tabContents = document.querySelectorAll('.tabContent');
    function activateTab(tabId){
      tabButtons.forEach(btn => {
        if(btn.dataset.tab === tabId) btn.classList.add('active');
        else btn.classList.remove('active');
      });
      tabContents.forEach(panel => {
        if(panel.id === tabId) panel.classList.add('active');
        else panel.classList.remove('active');
      });
    }
    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.tab;
        activateTab(target);
      });
    });
    // Activate default tab on load
    activateTab('tabGeneral');

    // Real-time updates for base colour pickers (ocean, land, hills, mountains, rivers, roads)
    // Throttled colour update function
    let colourUpdateTimeout;
    function updateColoursImmediate(){
      const col = {
        ocean: document.getElementById('colorOcean').value,
        land: document.getElementById('colorLand').value,
        hills: document.getElementById('colorHills').value,
        mountains: document.getElementById('colorMountains').value,
        river: document.getElementById('colorRiver').value,
        road: document.getElementById('colorRoad').value
      };
      OceanSteps = generateGradient(col.ocean || '#2b67bf', 8, 0.6);
      // Recompute land palette using MapColors length. Land, hills and mountains selections are appended to MapColors for a smooth gradient.
      const steps = MapColors.length > 0 ? MapColors.length : 9;
      MapColors = generateGradient(col.land || '#8fb065', steps, 0.5);
      if(col.hills){ MapColors.push(col.hills); }
      if(col.mountains){ MapColors.push(col.mountains); }
      RiverColor = col.river || RiverColor;
      RoadColor = col.road || RoadColor;
      renderBase();
      draw();
    }
    function updateColours(){
      clearTimeout(colourUpdateTimeout);
      colourUpdateTimeout = setTimeout(updateColoursImmediate, 200);
    }

    // Attach listeners for the new sliders to update their numeric displays
    const slopeLimitSlider = document.getElementById('slopeLimit');
    if(slopeLimitSlider){
      slopeLimitSlider.addEventListener('input', ()=>{ updateSliderDisplay('slopeLimitVal', slopeLimitSlider.value); });
      updateSliderDisplay('slopeLimitVal', slopeLimitSlider.value);
    }
    const moistureScaleSlider = document.getElementById('moistureScale');
    if(moistureScaleSlider){
      moistureScaleSlider.addEventListener('input', ()=>{ updateSliderDisplay('moistureScaleVal', parseFloat(moistureScaleSlider.value).toFixed(1)); });
      updateSliderDisplay('moistureScaleVal', parseFloat(moistureScaleSlider.value).toFixed(1));
    }
    const tempScaleSlider = document.getElementById('tempScale');
    if(tempScaleSlider){
      tempScaleSlider.addEventListener('input', ()=>{ updateSliderDisplay('tempScaleVal', parseFloat(tempScaleSlider.value).toFixed(1)); });
      updateSliderDisplay('tempScaleVal', parseFloat(tempScaleSlider.value).toFixed(1));
    }
    const biomeDivSlider = document.getElementById('biomeDiv');
    if(biomeDivSlider){
      biomeDivSlider.addEventListener('input', ()=>{ updateSliderDisplay('biomeDivVal', parseFloat(biomeDivSlider.value).toFixed(1)); });
      updateSliderDisplay('biomeDivVal', parseFloat(biomeDivSlider.value).toFixed(1));
    }
    const citySizeVarSlider = document.getElementById('citySizeVar');
    if(citySizeVarSlider){
      citySizeVarSlider.addEventListener('input', ()=>{ updateSliderDisplay('citySizeVarVal', parseFloat(citySizeVarSlider.value).toFixed(1)); });
      updateSliderDisplay('citySizeVarVal', parseFloat(citySizeVarSlider.value).toFixed(1));
    }
    const cityClusterSlider = document.getElementById('cityCluster');
    if(cityClusterSlider){
      cityClusterSlider.addEventListener('input', ()=>{ updateSliderDisplay('cityClusterVal', parseFloat(cityClusterSlider.value).toFixed(1)); });
      updateSliderDisplay('cityClusterVal', parseFloat(cityClusterSlider.value).toFixed(1));
    }
    const roadDensitySlider = document.getElementById('roadDensity');
    if(roadDensitySlider){
      roadDensitySlider.addEventListener('input', ()=>{ updateSliderDisplay('roadDensityVal', parseFloat(roadDensitySlider.value).toFixed(2)); });
      updateSliderDisplay('roadDensityVal', parseFloat(roadDensitySlider.value).toFixed(2));
    }
    const riverWidthSlider = document.getElementById('riverWidth');
    if(riverWidthSlider){
      riverWidthSlider.addEventListener('input', ()=>{ updateSliderDisplay('riverWidthVal', parseFloat(riverWidthSlider.value).toFixed(1)); });
      updateSliderDisplay('riverWidthVal', parseFloat(riverWidthSlider.value).toFixed(1));
    }

    // New sliders for additional tweak parameters
    const peakFreqSlider = document.getElementById('peakFreq');
    if(peakFreqSlider){
      peakFreqSlider.addEventListener('input', ()=>{ updateSliderDisplay('peakFreqVal', parseFloat(peakFreqSlider.value).toFixed(1)); });
      updateSliderDisplay('peakFreqVal', parseFloat(peakFreqSlider.value).toFixed(1));
    }
    const citySpacingSlider = document.getElementById('citySpacing');
    if(citySpacingSlider){
      citySpacingSlider.addEventListener('input', ()=>{ updateSliderDisplay('citySpacingVal', parseFloat(citySpacingSlider.value).toFixed(1)); });
      updateSliderDisplay('citySpacingVal', parseFloat(citySpacingSlider.value).toFixed(1));
    }
    const roadCurvatureSlider = document.getElementById('roadCurvature');
    if(roadCurvatureSlider){
      roadCurvatureSlider.addEventListener('input', ()=>{ updateSliderDisplay('roadCurvatureVal', parseFloat(roadCurvatureSlider.value).toFixed(1)); });
      updateSliderDisplay('roadCurvatureVal', parseFloat(roadCurvatureSlider.value).toFixed(1));
    }
    const ids = ['colorOcean','colorLand','colorHills','colorMountains','colorRiver','colorRoad'];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if(el){ el.addEventListener('input', updateColours); }
    });
  });

  // ---------- Export
  function exportPNG(){
    // Export the full map (base + overlay) at current world resolution
    const out = document.createElement('canvas');
    out.width = worldW; out.height = worldH; const c=out.getContext('2d');
    c.drawImage(baseOff,0,0); c.drawImage(overlayOff,0,0);
    const url = out.toDataURL('image/png');
    const a=document.createElement('a'); a.href=url; a.download=`map_${CURRENT.seed}.png`; a.click();
  }

  // ---------- Color helpers
  function hexToRgb(hex){ hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(x=>x+x).join(''); const num=parseInt(hex,16); return {r:(num>>16)&255,g:(num>>8)&255,b:num&255}; }
  function hslToHex(h,s,l){
    const a=s*Math.min(l,1-l); const f=(n,k=(n+h*12)%12)=>l - a*Math.max(-1, Math.min(k-3, Math.min(9-k,1)));
    const r = Math.round(255*f(0)), g=Math.round(255*f(8)), b=Math.round(255*f(4));
    return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
  }
  function hexWithAlpha(hex, a){ const {r,g,b} = hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }
  // Convert RGB values back to a hex string.
  function rgbToHex(r,g,b){
    const toHex = (v) => v.toString(16).padStart(2,'0');
    return '#'+toHex(r)+toHex(g)+toHex(b);
  }

  // Lighten a hex color by a given fraction (0..1). A fraction of 0 returns the original color, 1 returns white.
  function lightenColor(hex, fraction){
    const {r,g,b} = hexToRgb(hex);
    const R = Math.round(r + (255 - r) * fraction);
    const G = Math.round(g + (255 - g) * fraction);
    const B = Math.round(b + (255 - b) * fraction);
    return rgbToHex(R,G,B);
  }

  // Darken a hex color by a given fraction (0..1). A fraction of 0 returns the original color, 1 returns black.
  function darkenColor(hex, fraction){
    const {r,g,b} = hexToRgb(hex);
    const R = Math.round(r * (1 - fraction));
    const G = Math.round(g * (1 - fraction));
    const B = Math.round(b * (1 - fraction));
    return rgbToHex(R,G,B);
  }

  // Generate a gradient array from a base color by progressively lightening it.
  // maxLighten controls how much lighter the last color is compared to the base.
  function generateGradient(baseColor, steps, maxLighten){
    const arr=[];
    for(let i=0;i<steps;i++){
      const t = steps>1 ? (i/(steps-1)) : 0;
      arr.push(lightenColor(baseColor, t * maxLighten));
    }
    return arr;
  }

  // Banner colors behind city labels for improved readability.
  const NameBannerColor = 'rgba(28, 33, 52, 0.7)';
  const NameBannerBorder = 'rgba(0, 0, 0, 0.3)';
  function escapeHtml(s){ return s.replace(/[&<>"]+/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m])); }

  // ---------- Initial setup
  function init(){
    resizeCanvas();
    // Initial transform: fit world to screen height
    const dpr=DPI();
    SCALE = Math.min( (W/worldW), (H/worldH) );
    panX = (W - worldW*SCALE)/2; panY = (H - worldH*SCALE)/2;
  }

  // Generate a starter map
  init();
  generate({ seed: 'valoria', cities: 120, rivers: 12, waterPct: 45, chaos: 0.45, detail:'med' });

})();

// ===== End IIFE =====
</script>
</body>
</html>
