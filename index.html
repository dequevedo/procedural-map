<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Medieval Procedural Map (Single HTML)</title>
<style>
  :root{
    --bg:#0f1115; --panel:#1a1f2b; --accent:#e94f37; --muted:#9aa4b2; --ink:#e5e7eb;
    --ok:#2ecc71; --warn:#f39c12; --danger:#e74c3c; --shadow:rgba(0,0,0,.35);
  }
  html,body{height:100%;}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden;}
  #ui{position:fixed;left:12px;top:12px;background:var(--panel);border:1px solid #2a3142;border-radius:12px;box-shadow:0 10px 30px var(--shadow);padding:12px 12px 8px;width:310px;z-index:10}
  #ui h3{margin:0 0 6px 0;font-size:14px;color:#e2e8f0;letter-spacing:.3px}
  .row{display:grid;grid-template-columns:110px 1fr;gap:8px;align-items:center;margin:6px 0}
  .row label{color:#cbd5e1}
  .row input[type="text"], .row input[type="number"], .row select{width:100%;padding:6px 8px;background:#121621;border:1px solid #2a3142;border-radius:8px;color:#e2e8f0}
  .row input[type="range"]{width:100%}
  .btns{display:flex;gap:8px;margin-top:8px}
  .btn{flex:1;background:#243044;border:1px solid #324057;border-radius:10px;color:#eaeef4;padding:8px 10px;cursor:pointer}
  .btn:hover{filter:brightness(1.1)}
  .btn.primary{background:linear-gradient(180deg,#3a76ff,#2b5edb);border:none}
  .btn.export{background:linear-gradient(180deg,#24b37a,#179e66);border:none}
  #legend{position:fixed;left:12px;bottom:12px;background:var(--panel);border:1px solid #2a3142;border-radius:12px;box-shadow:0 10px 30px var(--shadow);padding:10px 12px;min-width:220px;z-index:6;max-height:45vh;overflow:auto}
  #legend h4{margin:0 0 6px 0;font-size:13px;color:#e2e8f0}
  #legend .item{display:flex;align-items:center;gap:8px;margin:6px 0}
  #legend .sw{width:14px;height:14px;border-radius:3px;border:1px solid #0006}
  #tooltip{position:fixed;pointer-events:none;background:#111827aa;color:#e5e7eb;padding:8px 10px;border-radius:8px;border:1px solid #ffffff18;backdrop-filter: blur(6px);z-index:9;transform:translate(-50%,-110%);white-space:nowrap}
  #tooltip.hidden{display:none}
  #panel{position:fixed;right:12px;top:12px;width:360px;max-width:40vw;background:var(--panel);border:1px solid #2a3142;border-radius:14px;box-shadow:0 10px 30px var(--shadow);z-index:11;display:none;flex-direction:column;max-height:85vh}
  #panel header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #2a3142}
  #panel header h3{margin:0;font-size:16px}
  #panel .content{padding:12px;overflow:auto}
  .kv{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:8px 0}
  .badge{padding:2px 6px;border-radius:6px;background:#2b3447;color:#e5e7eb;border:1px solid #3a4661;font-size:12px}
  .citymap{width:100%;height:200px;background:#0b0e14;border:1px solid #2a3142;border-radius:10px}
  canvas{display:block;position:fixed;inset:0}
  .notice{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);background:#111827f0;color:#e5e7eb;border:1px solid #ffffff22;padding:6px 10px;border-radius:10px;z-index:4}
  /* Banners behind labels */
  .label-banner{position:absolute}
</style>
</head>
<body>
  <div id="ui">
    <h3>‚öôÔ∏è Map Generator</h3>
    <div class="row"><label>Seed</label><input id="seed" type="text" placeholder="my-seed" /></div>
    <div class="row"><label>Cities</label><input id="cities" type="number" min="10" max="300" value="120" /></div>
    <div class="row"><label>Rivers</label><input id="rivers" type="number" min="0" max="50" value="12" /></div>
    <div class="row"><label>Water %</label><input id="water" type="range" min="20" max="75" value="45" /></div>
    <div class="row"><label>Chaos</label><input id="chaos" type="range" min="0" max="100" value="45" /></div>
    <div class="row"><label>Detail</label>
      <select id="detail">
        <option value="low">Low (fast)</option>
        <option value="med" selected>Medium</option>
        <option value="high">High</option>
      </select>
    </div>
    <div class="btns">
      <button id="gen" class="btn primary">Generate</button>
      <button id="export" class="btn export">Export PNG</button>
    </div>
  </div>
  <div id="legend"><h4>üè≥Ô∏è Factions</h4><div id="legendItems"></div></div>
  <div id="panel">
    <header><h3 id="panelTitle">City</h3><button id="panelClose" class="btn" style="flex:0 0 auto;padding:4px 8px">Close</button></header>
    <div class="content">
      <div class="kv">
        <div><div class="badge" id="panelType">Type</div></div>
        <div><div class="badge" id="panelFaction">Faction</div></div>
      </div>
      <div class="kv">
        <div>Population</div><div id="panelPop">‚Äî</div>
        <div>Prosperity</div><div id="panelPros">‚Äî</div>
      </div>
      <h4>üó∫Ô∏è City Minimap</h4>
      <canvas id="cityMini" class="citymap"></canvas>
      <p id="panelDesc" style="color:#cbd5e1"></p>
    </div>
  </div>
  <div id="tooltip" class="hidden"></div>
  <canvas id="map"></canvas>
  <div class="notice" id="hint">Drag to pan ‚Ä¢ Wheel to zoom (focuses cursor) ‚Ä¢ Hover for tooltip ‚Ä¢ Click to open city</div>
<script>
// ===============================
// Medieval Procedural Map ‚Äî Single File
// No external dependencies. All code here.
// Comments and identifiers in English per user preference.
// ===============================
(() => {
  // ---------- Utilities
  const DPI = () => (window.devicePixelRatio || 1);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const mix = lerp;
  const randFromSeed = (str) => {
    // xmur3 + mulberry32
    function xmur3(str){let h=1779033703^str.length;for(let i=0;i<str.length;i++){h=Math.imul(h^str.charCodeAt(i),3432918353);h=h<<13|h>>>19;}return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0;}}
    const seed = xmur3(str||('seed-'+Math.random()));
    let a=seed(), b=seed(), c=seed(), d=seed();
    return function(){
      // sfc32
      a>>>=0; b>>>=0; c>>>=0; d>>>=0; 
      let t=(a+b)|0; a=b^(b>>>9); b=(c+(c<<3))|0; c=(c<<21)|(c>>>11); d=(d+1)|0; t=(t+d)|0; c=(c+t)|0; return (t>>>0)/4294967296;
    }
  };
  const seededShuffle = (arr, rnd) => { for (let i=arr.length-1;i>0;i--){const j=Math.floor(rnd()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; };
  const hash2 = (x,y) => { // deterministic hash -> 0..1
    let h = (x*374761393 + y*668265263) ^ (x*1442695040888963n?0:0); // keep simple int math
    // JS integer overflow is okay; fallback pure JS:
    h = (x*92837111 ^ y*689287499) >>> 0; 
    return (h & 0xffffffff) / 0xffffffff;
  };
  // 2D value noise (fast, tiled via lattice). fBm for chaos control.
  function makeValueNoise2D(seedStr){
    const rnd = randFromSeed('noise-'+seedStr);
    const perm = new Uint16Array(512);
    for(let i=0;i<256;i++) perm[i]=i;
    seededShuffle(perm.subarray(0,256), rnd);
    for(let i=0;i<256;i++) perm[256+i]=perm[i];
    const grad = new Float32Array(512);
    for(let i=0;i<512;i++) grad[i]=rnd();
    const fade = t=>t*t*(3-2*t); // smoothstep
    function value(x,y){
      const xi = Math.floor(x)&255, yi=Math.floor(y)&255;
      const xf = x - Math.floor(x), yf = y - Math.floor(y);
      const aa = perm[perm[xi] + yi];
      const ab = perm[perm[xi] + yi+1];
      const ba = perm[perm[xi+1] + yi];
      const bb = perm[perm[xi+1] + yi+1];
      const u = fade(xf), v = fade(yf);
      const x1 = mix(grad[aa], grad[ba], u);
      const x2 = mix(grad[ab], grad[bb], u);
      return mix(x1, x2, v); // 0..1 approx
    }
    function fbm(x,y,octaves=5,lacunarity=2,gain=.5){
      let amp=1, freq=1, sum=0, norm=0;
      for(let i=0;i<octaves;i++){
        sum += value(x*freq, y*freq)*amp;
        norm += amp;
        amp *= gain; freq *= lacunarity;
      }
      return sum/norm; // ~0..1
    }
    return {value, fbm};
  }

  // Rounded rectangle helper
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, Math.min(w,h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // ---------- Palettes (step colors, no smooth gradients)
  const OceanSteps = ["#0b265a","#0f3275","#154091","#1d53aa","#2b67bf","#3d7ed0","#5396de","#6dafea"];
  const Beach = "#e9d8a6";
  const LandSteps = ["#dfe8b8","#c9d29c","#b0c27b","#8fb065","#6b9b59","#4e8a4f","#3e6f45","#355a3d","#2e4b36"]; // plains -> forest
  const HillSteps = ["#847a5a","#6f6549","#5c513d"]; // hills
  const MountainSteps = ["#6b6b6b","#8a8a8a","#b2b2b2","#e4e4e4"]; // rocky -> snow caps
  const RiverColor = "#4fb7ff";
  const RoadColor = "#caa66a";
  const RoadEdge = "#6e5430";
  const BridgeColor = "#d7d7d7";

  // ---------- Core State
  const canvas = document.getElementById('map');
  const ctx = canvas.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const panel = document.getElementById('panel');
  const panelTitle = document.getElementById('panelTitle');
  const panelType = document.getElementById('panelType');
  const panelFaction = document.getElementById('panelFaction');
  const panelPop = document.getElementById('panelPop');
  const panelPros = document.getElementById('panelPros');
  const panelDesc = document.getElementById('panelDesc');
  const panelClose = document.getElementById('panelClose');
  const cityMini = document.getElementById('cityMini');
  const legendItems = document.getElementById('legendItems');

  let W=0, H=0, SCALE=1, panX=0, panY=0;
  let isDragging=false, dragStartX=0, dragStartY=0, panStartX=0, panStartY=0;
  let worldW=1024, worldH=768; // logical map size in world units
  let baseOff = document.createElement('canvas'); // base terrain + rivers
  let baseCtx = baseOff.getContext('2d');
  let overlayOff = document.createElement('canvas'); // roads + cities + labels
  let overlayCtx = overlayOff.getContext('2d');

  let CURRENT = {
    seed: 'demo', cities: [], pois: [], factions: [], roads: [], rivers: [], riverMask:null,
    waterLevel: .45, chaos: .45, detail:'med', 
    height: null, slope: null, landMask:null, coastSegments:[], legend:[], 
  };

  // ---------- Coordinate transforms
  function resizeCanvas(){
    const dpr = DPI();
    W = canvas.width = Math.floor(window.innerWidth*dpr);
    H = canvas.height = Math.floor(window.innerHeight*dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    // Keep existing pan/zoom, only need redraw
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  function worldToScreen(x,y){ return { x: x*SCALE + panX, y: y*SCALE + panY }; }
  function screenToWorld(x,y){ return { x: (x - panX)/SCALE, y: (y - panY)/SCALE }; }

  // Zoom focusing the cursor position
  function onWheel(e){
    e.preventDefault();
    const {clientX, clientY} = e;
    const rect = canvas.getBoundingClientRect();
    const sx = (clientX - rect.left) * DPI();
    const sy = (clientY - rect.top) * DPI();
    const before = screenToWorld(sx, sy);
    const zoom = Math.exp(-e.deltaY * 0.001);
    const newScale = clamp(SCALE * zoom, 0.3, 4);
    SCALE = newScale;
    const after = {x: before.x, y: before.y};
    panX = sx - after.x * SCALE;
    panY = sy - after.y * SCALE;
    draw();
  }

  function onMouseDown(e){
    isDragging = true;
    dragStartX = e.clientX; dragStartY = e.clientY;
    panStartX = panX; panStartY = panY;
  }
  function onMouseMove(e){
    if(isDragging){
      const dx = (e.clientX - dragStartX) * DPI();
      const dy = (e.clientY - dragStartY) * DPI();
      panX = panStartX + dx; panY = panStartY + dy;
      draw();
    }
    // Hover tooltip
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPI();
    const sy = (e.clientY - rect.top) * DPI();
    const wp = screenToWorld(sx, sy);
    const hit = hitTest(wp.x, wp.y);
    if(hit){
      tooltip.classList.remove('hidden');
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top = e.clientY + 'px';
      tooltip.innerHTML = hit.tooltip;
    } else {
      tooltip.classList.add('hidden');
    }
  }
  function onMouseUp(){ isDragging=false; }
  function onClick(e){
    const rect = canvas.getBoundingClientRect();
    const sx = (e.clientX - rect.left) * DPI();
    const sy = (e.clientY - rect.top) * DPI();
    const wp = screenToWorld(sx, sy);
    const hit = hitTest(wp.x, wp.y);
    if(hit && hit.kind==='city'){
      openCityPanel(hit.data);
    }
  }
  canvas.addEventListener('wheel', onWheel, {passive:false});
  canvas.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('click', onClick);

  panelClose.addEventListener('click', ()=>{panel.style.display='none'});

  // ---------- Map Generation Pipeline
  function generate(opts){
    const seed = opts.seed || 'seed';
    const detail = opts.detail || 'med';
    const rnd = randFromSeed(seed);
    CURRENT.seed = seed;

    // Resolution by detail (logical world size)
    const base = {low: 800, med: 1200, high: 1600}[detail];
    worldW = base; worldH = Math.floor(base*0.65);

    // Prepare canvases
    baseOff.width = worldW; baseOff.height = worldH;
    overlayOff.width = worldW; overlayOff.height = worldH;

    // Noise & heightfield
    const {fbm} = makeValueNoise2D(seed);
    const chaos = opts.chaos ?? .45; // 0..1
    const waterPct = (opts.waterPct ?? .45)/100; // expect 20..75 in UI, normalize later

    // Generate raw height, then warp for islands: radial falloff
    const w = worldW, h = worldH;
    const height = new Float32Array(w*h);
    const slope = new Float32Array(w*h);

    // Radial mask for island continents
    const cx=w/2, cy=h/2; const maxD = Math.hypot(cx,cy);

    // Octaves depend on detail and chaos
    const oct = clamp(Math.round(4 + chaos*4), 3, 8);
    const lac = 2.0; const gain = 0.5 + chaos*0.35;

    // Precompute height
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const nx = x/w - 0.5, ny = y/h - 0.5;
        const d = Math.hypot(nx,ny);
        const island = clamp(1.0 - d*1.35, 0, 1); // more chaotic coast
        const n = fbm(x*0.006 + chaos*2.17, y*0.006 - chaos*1.13, oct, lac, gain); // 0..1
        // Add some ridged noise for mountains
        const r = Math.abs(fbm(x*0.015+97, y*0.015-37, 3, 2.2, 0.55)*2-1);
        const mnt = Math.pow(1-r, 3);
        let val = (n*0.7 + mnt*0.3);
        val = val*island + (val*0.1)*(1-island); // soften edges into ocean
        height[y*w+x] = val; // 0..1
      }
    }
    // Normalize & water level
    let min=1e9,max=-1e9; for(let i=0;i<height.length;i++){ const v=height[i]; if(v<min)min=v; if(v>max)max=v; }
    const inv = 1/(max-min);
    for(let i=0;i<height.length;i++){ height[i] = (height[i]-min)*inv; }

    // Adjust global water threshold by target water % via binary search
    const desiredWater = waterPct; // 0.2..0.75 (UI enforces)
    let lo=0, hi=1, lvl=0.5;
    for(let k=0;k<10;k++){
      lvl = (lo+hi)*0.5;
      let cnt=0; for(let i=0;i<height.length;i++) if(height[i]<lvl) cnt++;
      const ratio = cnt/height.length;
      if(ratio>desiredWater) hi=lvl; else lo=lvl;
    }
    const waterLevel = lvl; CURRENT.waterLevel=waterLevel;

    // Slope (for placement & rivers)
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i=y*w+x;
        const dzdx=(height[i+1]-height[i-1])*0.5;
        const dzdy=(height[i+w]-height[i-w])*0.5;
        slope[i]=Math.hypot(dzdx,dzdy);
      }
    }

    // Land/Water mask
    const landMask = new Uint8Array(w*h);
    for(let i=0;i<height.length;i++) landMask[i] = height[i]>=waterLevel?1:0;

    // Coast outline via grid-edge scan (marching squares-lite)
    const coastSegments = [];
    for(let y=0;y<h-1;y++){
      for(let x=0;x<w-1;x++){
        const i=y*w+x;
        const a=landMask[i], b=landMask[i+1], c=landMask[i+w], d=landMask[i+w+1];
        const code = a*8+b*4+c*2+d*1;
        if(code===0||code===15) continue; // fully water or land
        // Collect mid-edge points depending on case
        const mx=x+.5, my=y+.5;
        const edges=[];
        if(a!==b) edges.push({x:mx, y:y});
        if(b!==d) edges.push({x:x+1, y:my});
        if(c!==d) edges.push({x:mx, y:y+1});
        if(a!==c) edges.push({x:x, y:my});
        if(edges.length>=2){ coastSegments.push(edges); }
      }
    }

    // Rivers via downhill flow accumulation from random high points
    const riverCount = clamp(Math.round(opts.rivers ?? 10), 0, 60);
    const flow = new Float32Array(w*h);
    const riverMask = new Uint8Array(w*h);

    // Pick sources at elevated, inland cells
    const candidates = [];
    for(let y=2;y<h-2;y++){
      for(let x=2;x<w-2;x++){
        const i=y*w+x; const elev=height[i];
        if(landMask[i] && elev>waterLevel+0.08) candidates.push({x,y,elev});
      }
    }
    seededShuffle(candidates, rnd);
    const sources = candidates.slice(0, riverCount*3); // pick extra; we'll prune short ones

    const rivers = [];
    function stepDownhill(x,y){
      // move to lowest neighbor (8-neighborhood) with slight randomness
      let bestX=x, bestY=y, best=height[y*w+x];
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        if(dx===0&&dy===0) continue; const nx=x+dx, ny=y+dy; if(nx<1||ny<1||nx>=w-1||ny>=h-1) continue;
        const z=height[ny*w+nx] + (Math.abs(dx)+Math.abs(dy)>1?0.002:0) + rnd()*0.001; // prefer cardinal
        if(z<best){ best=z; bestX=nx; bestY=ny; }
      }
      return {x:bestX,y:bestY,val:best};
    }

    for(let s=0,added=0; s<sources.length && added<riverCount; s++){
      let {x,y} = sources[s];
      // Walk downhill until water or edge, accumulate flow
      const path=[]; let safety=0;
      if(!landMask[y*w+x]) continue;
      while(safety++<5000){
        path.push({x,y});
        const i=y*w+x;
        flow[i]+=1;
        // Delta branching near sea
        if(height[i] < waterLevel+0.01){ break; }
        const nxt = stepDownhill(x,y);
        if(nxt.x===x && nxt.y===y) break; // flat pit
        x=nxt.x; y=nxt.y;
        if(x<=1||y<=1||x>=w-2||y>=h-2) break;
      }
      if(path.length>40){
        // Mark mask with variable width by downstream flow
        for(let k=0;k<path.length;k++){
          const p=path[k]; const i=p.y*w+p.x; const f = flow[i];
          const radius = Math.floor(1 + Math.min(6, Math.sqrt(f)*0.6 + k/path.length*1.5));
          for(let ry=-radius;ry<=radius;ry++) for(let rx=-radius;rx<=radius;rx++){
            const nx=p.x+rx, ny=p.y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue;
            const di = ny*w+nx; riverMask[di]=1;
          }
        }
        // Build a simplified polyline for drawing
        const simplified = simplifyPath(path, 1.2);
        rivers.push(simplified);
        added++;
      }
    }

    // Cities & POIs placement
    const totalCities = clamp(parseInt(opts.cities || 120), 5, 400);
    const citySpots = [];
    for(let y=3;y<h-3;y+=3){
      for(let x=3;x<w-3;x+=3){
        const i=y*w+x; if(!landMask[i]) continue; 
        if(height[i] < waterLevel+0.01) continue; // avoid swamps
        // Prefer flatter ground & near rivers/coast moderately
        const s = slope[i]; if(s>0.10) continue; // too steep
        let score = (height[i]-waterLevel)*2.0 + (0.12 - s)*2.5;
        // proximity to river
        const nearRiver = isNearMask(x,y,riverMask,w,h,4)?1:0; score += nearRiver*0.25;
        citySpots.push({x,y,score});
      }
    }
    citySpots.sort((a,b)=>b.score-a.score);
    const taken = new Uint8Array(w*h);
    const cities = [];
    const types = ['village','town','city','capital','port'];

    function isNearWater(x,y,dist){
      const d=dist|0; for(let ry=-d;ry<=d;ry++) for(let rx=-d;rx<=d;rx++){
        const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; const ii=ny*w+nx; if(!landMask[ii]) return true; }
      return false;
    }

    // Factions
    const factionCount = clamp(Math.floor(4 + rnd()*4), 3, 7);
    const factions = [];
    const hueBase = rnd();
    for(let i=0;i<factionCount;i++){
      const hue = (hueBase + i/factionCount*0.9) % 1;
      const col = hslToHex(hue, 0.55, 0.55);
      factions.push({id:i, name: makeFactionName(rnd), color:col});
    }

    // Place cities, avoiding collisions
    for(let i=0,placed=0; i<citySpots.length && placed<totalCities; i++){
      const c = citySpots[i];
      const ix=c.y*w+c.x; if(taken[ix]) continue;
      // spacing
      if(hasNeighborTaken(taken,w,h,c.x,c.y, 14)) continue;
      const nearSea = isNearWater(c.x,c.y,10);
      const t = nearSea && rnd()<0.3 ? 'port' : chooseType(rnd);
      const pop = Math.floor( (t==='village'?200+(rnd()*800): t==='town'? 1200+(rnd()*3000): t==='city'? 8000+(rnd()*12000): t==='capital'? 20000+(rnd()*40000) : 1500+(rnd()*3000)) );
      const prosp = ['poor','modest','prosperous','rich'][Math.floor(rnd()*4)];
      const faction = Math.floor(rnd()*factions.length);
      const name = makePlaceName(rnd, t);
      cities.push({id:placed, name, type:t, x:c.x, y:c.y, pop, faction, prosperity:prosp});
      markTaken(taken,w,h,c.x,c.y, 14);
      placed++;
    }

    // POIs
    const poiTypes = ['ruins','tower','shrine','crypt'];
    const pois = [];
    let tryPoi = 0; while(pois.length < Math.min(60, Math.floor(totalCities*0.4)) && tryPoi < 5000){
      tryPoi++;
      const x = Math.floor(rnd()*w), y=Math.floor(rnd()*h); const i=y*w+x;
      if(!landMask[i]) continue; if(slope[i]>0.14) continue; if(isNearAnyCity(cities,x,y, 18)) continue;
      const t = poiTypes[Math.floor(rnd()*poiTypes.length)];
      pois.push({id:pois.length, type:t, x,y, name: makePOIName(rnd,t)});
    }

    // Roads: connect major hubs via MST + some local links. Organic curves.
    const hubs = cities.filter(c=>['town','city','capital','port'].includes(c.type));
    // Pick top ~50 hubs by pop (cap for perf)
    hubs.sort((a,b)=>b.pop-a.pop); const maxHubs = Math.min(50, hubs.length);
    const nodes = hubs.slice(0,maxHubs);
    const edges = computeMST(nodes, (a,b)=>Math.hypot(a.x-b.x,a.y-b.y));
    // Add a handful of extra local connections
    const extra = Math.floor(nodes.length*0.35);
    for(let k=0;k<extra;k++){
      const a = nodes[Math.floor(rnd()*nodes.length)];
      // nearest neighbor not already connected
      let best=null,bestD=1e9;
      for(const b of nodes){ if(a===b) continue; const d=Math.hypot(a.x-b.x,a.y-b.y); if(d<bestD){bestD=d;best=b;} }
      edges.push([a,best]);
    }

    // Build organic road polylines with jitter & bezier smoothing
    const roads = [];
    const riverMaskSet = riverMask;
    for(const [a,b] of edges){
      const poly = jitteredPath(a.x,a.y,b.x,b.y, rnd, landMask, w,h);
      const curve = smoothPath(poly);
      // Detect river crossings for bridges
      const bridges = computeBridges(curve, riverMaskSet, w,h);
      roads.push({a,b, path:curve, bridges});
    }

    // Prepare legend HTML
    legendItems.innerHTML = '';
    for(const f of factions){
      const div = document.createElement('div'); div.className='item';
      div.innerHTML = `<span class="sw" style="background:${f.color}"></span><span>${escapeHtml(f.name)}</span>`;
      legendItems.appendChild(div);
    }

    // Store
    CURRENT = { ...CURRENT, height, slope, landMask, coastSegments, rivers, riverMask, cities, pois, factions, roads, detail, chaos: chaos, waterLevel };

    // Render layers
    renderBase();
    renderOverlay();
    draw();
  }

  // ---------- Geometry helpers
  function simplifyPath(path, tol){
    // Ramer‚ÄìDouglas‚ÄìPeucker for grid points
    if(path.length<=2) return path.slice();
    const sqTol = tol*tol;
    function sqDist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
    function sqSegDist(p,a,b){
      let x=a.x, y=a.y; let dx=b.x-x, dy=b.y-y; if(dx!==0||dy!==0){
        const t=((p.x-x)*dx+(p.y-y)*dy)/(dx*dx+dy*dy); if(t>1){x=b.x;y=b.y;} else if(t>0){x+=dx*t;y+=dy*t;}
      }
      dx=p.x-x; dy=p.y-y; return dx*dx+dy*dy;
    }
    function simplifyDP(points, first, last, sqTol, out){
      let maxSq= sqTol; let index=null;
      for(let i=first+1;i<last;i++){
        const sq = sqSegDist(points[i], points[first], points[last]);
        if(sq>maxSq){ index=i; maxSq=sq; }
      }
      if(index){ if(index-first>1) simplifyDP(points, first, index, sqTol, out); out.push(points[index]); if(last-index>1) simplifyDP(points, index, last, sqTol, out); }
    }
    const out=[path[0]]; simplifyDP(path,0,path.length-1,sqTol,out); out.push(path[path.length-1]); return out;
  }
  function smoothPath(points){
    // Catmull-Rom to polyline sampling
    if(points.length<3) return points.slice();
    const out=[]; const s=8; // samples per segment
    for(let i=-1;i<points.length-2;i++){
      const p0=points[Math.max(i,0)], p1=points[i+1], p2=points[i+2], p3=points[Math.min(i+3, points.length-1)];
      for(let j=0;j<s;j++){
        const t=j/s; const t2=t*t, t3=t2*t;
        const x=0.5*((2*p1.x)+(-p0.x+p2.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*t2+(-p0.x+3*p1.x-3*p2.x+p3.x)*t3);
        const y=0.5*((2*p1.y)+(-p0.y+p2.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*t2+(-p0.y+3*p1.y-3*p2.y+p3.y)*t3);
        out.push({x,y});
      }
    }
    out.push(points[points.length-1]);
    return out;
  }
  function jitteredPath(x0,y0,x1,y1, rnd, landMask, w,h){
    const segs = Math.max(12, Math.min(80, Math.floor(Math.hypot(x1-x0,y1-y0)/12)));
    const pts=[];
    for(let i=0;i<=segs;i++){
      const t=i/segs; let x=lerp(x0,x1,t), y=lerp(y0,y1,t);
      // Perpendicular jitter for organic feel, avoid water bias a bit
      const nx=-(y1-y0), ny=(x1-x0); const nlen=Math.hypot(nx,ny)||1; const ux=nx/nlen, uy=ny/nlen;
      const jitter = (rnd()-0.5)*8*(1-(Math.abs(0.5-t)*1.2));
      x += ux*jitter; y += uy*jitter;
      // Slight attraction to land if near coast
      const ix=Math.floor(clamp(x,1,w-2)), iy=Math.floor(clamp(y,1,h-2));
      const ixy=iy*w+ix; if(!landMask[ixy]){ x=(x+lerp(x0,x1,t))/2; y=(y+lerp(y0,y1,t))/2; }
      pts.push({x,y});
    }
    return pts;
  }
  function computeBridges(path, riverMask, w,h){
    const bridges=[]; let inRiver=false;
    for(let i=0;i<path.length;i++){
      const p=path[i]; const x=Math.floor(p.x), y=Math.floor(p.y);
      if(x<0||y<0||x>=w||y>=h) continue;
      const r = riverMask[y*w+x]===1;
      if(r && !inRiver){ inRiver=true; bridges.push({x:p.x,y:p.y}); }
      if(!r && inRiver){ inRiver=false; }
    }
    return bridges;
  }
  function isNearMask(x,y,mask,w,h,dist){
    const d=dist|0; for(let ry=-d;ry<=d;ry++) for(let rx=-d;rx<=d;rx++){
      const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; if(mask[ny*w+nx]) return true; }
    return false;
  }
  function hasNeighborTaken(taken,w,h,x,y,r){
    for(let ry=-r;ry<=r;ry++) for(let rx=-r;rx<=r;rx++){
      const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; if(taken[ny*w+nx]) return true; }
    return false;
  }
  function markTaken(taken,w,h,x,y,r){
    for(let ry=-r;ry<=r;ry++) for(let rx=-r;rx<=r;rx++){
      const nx=x+rx, ny=y+ry; if(nx<0||ny<0||nx>=w||ny>=h) continue; taken[ny*w+nx]=1; }
  }
  function computeMST(nodes, dist){
    // Prim's
    if(nodes.length<=1) return [];
    const inTree = new Set([0]);
    const edges=[];
    while(inTree.size < nodes.length){
      let best=null, bestI=-1, bestJ=-1, bestD=1e9;
      for(const i of inTree){
        for(let j=0;j<nodes.length;j++) if(!inTree.has(j)){
          const d = dist(nodes[i], nodes[j]); if(d<bestD){ bestD=d; bestI=i; bestJ=j; best=[nodes[i], nodes[j]]; }
        }
      }
      edges.push(best);
      inTree.add(bestJ);
    }
    return edges;
  }

  // ---------- Rendering
  function renderBase(){
    const {height, landMask, coastSegments, waterLevel, rivers, riverMask} = CURRENT;
    const w=worldW, h=worldH; const ctx=baseCtx; ctx.clearRect(0,0,w,h);

    // Step color fill
    const img = ctx.createImageData(w,h); const data = img.data;
    for(let i=0;i<height.length;i++){
      const z=height[i]; let r=0,g=0,b=0; // choose step palette
      if(z<waterLevel){
        const t = clamp((z/(waterLevel+1e-6))*OceanSteps.length,0,OceanSteps.length-1);
        const col = hexToRgb(OceanSteps[Math.floor(t)]);
        r=col.r; g=col.g; b=col.b;
      } else {
        const zRel = (z-waterLevel)/(1-waterLevel+1e-6);
        let col;
        if(zRel<0.08){ col=hexToRgb(Beach); }
        else if(zRel<0.45){ const t=Math.floor((zRel-0.08)/0.37 * LandSteps.length); col=hexToRgb(LandSteps[clamp(t,0,LandSteps.length-1)]); }
        else if(zRel<0.75){ const t=Math.floor((zRel-0.45)/0.30 * HillSteps.length); col=hexToRgb(HillSteps[clamp(t,0,HillSteps.length-1)]); }
        else { const t=Math.floor((zRel-0.75)/0.25 * MountainSteps.length); col=hexToRgb(MountainSteps[clamp(t,0,MountainSteps.length-1)]); }
        r=col.r; g=col.g; b=col.b;
      }
      data[i*4+0]=r; data[i*4+1]=g; data[i*4+2]=b; data[i*4+3]=255;
    }
    ctx.putImageData(img,0,0);

    // Rivers on top (variable width)
    ctx.save();
    ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.strokeStyle=RiverColor;
    for(const river of rivers){
      ctx.beginPath();
      for(let i=0;i<river.length;i++){
        const p=river[i]; const t=i/river.length; const wv= 1 + t*2.2; // widen downstream
        if(i===0){ ctx.moveTo(p.x,p.y); ctx.lineWidth=wv; }
        else { ctx.lineTo(p.x,p.y); ctx.lineWidth=wv; }
      }
      ctx.stroke();
    }
    ctx.restore();

    // Coast outline: thin dark line between land and water
    ctx.save();
    ctx.strokeStyle = '#0a0c10';
    ctx.lineWidth = 1.25;
    ctx.globalAlpha = 0.9;
    for(const seg of coastSegments){
      ctx.beginPath(); ctx.moveTo(seg[0].x, seg[0].y);
      for(let i=1;i<seg.length;i++){ ctx.lineTo(seg[i].x, seg[i].y); }
      ctx.stroke();
    }
    ctx.restore();
  }

  function renderOverlay(){
    const {cities, roads, factions, pois} = CURRENT;
    const w=worldW, h=worldH; const ctx=overlayCtx; ctx.clearRect(0,0,w,h);

    // Roads (under cities)
    ctx.save();
    ctx.lineCap='round'; ctx.lineJoin='round';
    for(const r of roads){
      // edge shadow
      ctx.strokeStyle = RoadEdge; ctx.lineWidth = 4.6; ctx.globalAlpha=0.45;
      ctx.beginPath(); for(let i=0;i<r.path.length;i++){ const p=r.path[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke();
      // road body
      ctx.strokeStyle = RoadColor; ctx.lineWidth = 3.2; ctx.globalAlpha=0.95;
      ctx.beginPath(); for(let i=0;i<r.path.length;i++){ const p=r.path[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke();
      // bridges
      ctx.globalAlpha=1.0; ctx.fillStyle=BridgeColor; ctx.strokeStyle='#0007';
      for(const b of r.bridges){
        const size=6; roundRect(ctx, b.x-size, b.y-2, size*2, 4, 2); ctx.fill(); ctx.stroke();
      }
    }
    ctx.restore();

    // POIs
    for(const p of pois){
      drawPOI(ctx, p);
    }

    // Cities and labels
    ctx.save();
    ctx.textAlign='center'; ctx.textBaseline='top';
    for(const c of cities){
      // banner behind name for towns/cities (faction color)
      const color = factions[c.faction]?.color || '#888';
      const label = c.name;
      let fontSize = c.type==='village'? 10 : c.type==='town'? 12 : c.type==='city'? 14 : c.type==='capital'? 16 : 12;
      ctx.font = `bold ${fontSize}px/1.2 system-ui,Segoe UI,Roboto`;
      const m = ctx.measureText(label);
      const padX=6, padY=3; const bw=m.width+padX*2, bh=fontSize+padY*2;
      if(c.type!=='village'){
        ctx.save();
        ctx.globalAlpha=0.85; ctx.fillStyle=hexWithAlpha(color, 0.18); ctx.strokeStyle=hexWithAlpha(color, 0.6);
        roundRect(ctx, c.x - bw/2, c.y - 20 - padY, bw, bh, 6); ctx.fill(); ctx.stroke();
        ctx.restore();
      }
      // dot
      ctx.fillStyle = c.type==='village' ? '#dcdcdc' : '#f4e4a4';
      ctx.strokeStyle = '#0008';
      ctx.beginPath(); ctx.arc(c.x, c.y-4, c.type==='village'? 2.2 : 3.0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      // label
      ctx.fillStyle = c.type==='village'? '#bfc8d6' : c.type==='city'||c.type==='capital' ? '#ff5252' : '#e8e0c0';
      ctx.fillText(label, c.x, c.y-20);
    }
    ctx.restore();
  }

  function draw(){
    // Composite base + overlay to main canvas with current transform
    ctx.save();
    ctx.clearRect(0,0,W,H);
    ctx.imageSmoothingEnabled = false; // preserve crisp steps
    ctx.setTransform(SCALE,0,0,SCALE, panX, panY);
    ctx.drawImage(baseOff, 0,0);
    ctx.drawImage(overlayOff, 0,0);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.restore();
  }

  // ---------- POI Drawing
  function drawPOI(ctx, poi){
    const {x,y,type,name} = poi;
    ctx.save();
    ctx.strokeStyle='#0009';
    ctx.fillStyle = '#d1d5db';
    switch(type){
      case 'ruins':
        // broken arch
        ctx.beginPath(); ctx.moveTo(x-4,y-2); ctx.lineTo(x-1,y-8); ctx.lineTo(x+1,y-8); ctx.lineTo(x+4,y-2); ctx.stroke();
        break;
      case 'tower':
        ctx.beginPath(); ctx.rect(x-2,y-8,4,6); ctx.moveTo(x-2,y-8); ctx.lineTo(x+2,y-8); ctx.stroke();
        break;
      case 'shrine':
        ctx.beginPath(); ctx.arc(x,y-6,3,0,Math.PI*2); ctx.stroke();
        break;
      case 'crypt':
        ctx.beginPath(); ctx.moveTo(x-4,y-2); ctx.lineTo(x,y-8); ctx.lineTo(x+4,y-2); ctx.closePath(); ctx.stroke();
        break;
    }
    ctx.font='10px system-ui,Segoe UI,Roboto'; ctx.textAlign='center'; ctx.textBaseline='top';
    ctx.fillStyle='#9aa4b2'; ctx.fillText(name, x, y-18);
    ctx.restore();
  }

  // ---------- Hit Testing for tooltip & clicks
  function hitTest(wx, wy){
    const {cities, pois} = CURRENT;
    // Cities first
    for(let i=0;i<cities.length;i++){
      const c=cities[i]; const dx=wx-c.x, dy=wy-c.y; if(dx*dx+dy*dy< 10*10){
        return {kind:'city', data:c, tooltip: `<b>${escapeHtml(c.name)}</b><br>${c.type} ‚Ä¢ pop ${c.pop.toLocaleString()}<br>Faction: ${escapeHtml(CURRENT.factions[c.faction]?.name||'‚Äî')}`};
      }
    }
    // POIs smaller radius
    for(let i=0;i<pois.length;i++){
      const p=pois[i]; const dx=wx-p.x, dy=wy-p.y; if(dx*dx+dy*dy< 8*8){
        return {kind:'poi', data:p, tooltip: `${escapeHtml(p.name)} (${p.type})`};
      }
    }
    return null;
  }

  // ---------- City Panel + Minimap
  function openCityPanel(city){
    panelTitle.textContent = city.name;
    panelType.textContent = city.type;
    panelFaction.textContent = CURRENT.factions[city.faction]?.name || '‚Äî';
    panelPop.textContent = city.pop.toLocaleString();
    panelPros.textContent = city.prosperity;
    panelDesc.textContent = describeCity(city);
    panel.style.display='flex';
    drawCityMini(city);
  }

  function drawCityMini(city){
    const dpr=DPI(); const w=cityMini.clientWidth*dpr, h=cityMini.clientHeight*dpr;
    cityMini.width=w; cityMini.height=h; const c=cityMini.getContext('2d');
    c.clearRect(0,0,w,h); c.fillStyle='#0b0e14'; c.fillRect(0,0,w,h);

    // Use a per-city RNG for layout variety
    const rnd = randFromSeed(CURRENT.seed + '|city|' + city.id);
    c.save(); c.translate(w/2,h/2); c.scale(1,1);

    // Road styles
    c.lineCap='round'; c.lineJoin='round';

    if(city.type==='village'){
      // organic branching lanes
      for(let k=0;k<6;k++){
        const ang = rnd()*Math.PI*2; let len = 40 + rnd()*30; let x=0,y=0; c.beginPath(); c.moveTo(0,0);
        while(len>0){ x+=Math.cos(ang+(rnd()-0.5)*0.4)*6; y+=Math.sin(ang+(rnd()-0.5)*0.4)*6; c.lineTo(x,y); len-=6; }
        c.strokeStyle='#aa8955'; c.lineWidth=2.2; c.stroke();
      }
      drawHouses(c, rnd, 28, 38, 2.5);
    } else if(city.type==='town'){
      // grid-like
      c.strokeStyle='#b49661'; c.lineWidth=2.4;
      for(let i=-3;i<=3;i++){
        c.beginPath(); c.moveTo(-70,i*20); c.lineTo(70,i*20); c.stroke();
        c.beginPath(); c.moveTo(i*20,-70); c.lineTo(i*20,70); c.stroke();
      }
      drawBlocks(c, rnd, 18, 16);
    } else if(city.type==='city' || city.type==='capital'){
      // radial ring roads
      const rings = city.type==='capital'? 4:3; const spokes = 8+Math.floor(rnd()*4);
      c.strokeStyle='#bfa070';
      for(let r=1; r<=rings; r++){ c.beginPath(); c.arc(0,0, r*25, 0, Math.PI*2); c.lineWidth= city.type==='capital'? 3.2:2.6; c.stroke(); }
      for(let s=0;s<spokes;s++){ const ang=s*(Math.PI*2/spokes); c.beginPath(); c.moveTo(0,0); c.lineTo(Math.cos(ang)*rings*25, Math.sin(ang)*rings*25); c.lineWidth=2.4; c.stroke(); }
      drawBlocksRadial(c, rnd, rings, spokes);
    } else if(city.type==='port'){
      // harbor area
      c.fillStyle='#0b3a5a'; c.fillRect(-w/2,-h/2, w/2+20, h);
      c.strokeStyle='#b49661'; c.lineWidth=2.4; c.beginPath(); c.moveTo(0,-h/2+14); c.lineTo(0,h/2-14); c.stroke();
      for(let d=-3; d<=3; d++){ c.beginPath(); c.moveTo(0, d*30); c.lineTo(70, d*30 + (rnd()-0.5)*10); c.stroke(); }
      drawDocks(c, rnd);
    }

    c.restore();
  }
  function drawHouses(c, rnd, countA, countB, size){
    c.fillStyle='#d4cab5';
    for(let i=0;i<countA;i++){
      const x=-80 + rnd()*160, y=-80+rnd()*160; if(Math.hypot(x,y)>90) continue; c.fillRect(x,y, size+ rnd()*3, size + rnd()*3);
    }
    for(let i=0;i<countB;i++){
      const ang = rnd()*Math.PI*2; const r= 30 + rnd()*60; const x=Math.cos(ang)*r, y=Math.sin(ang)*r; c.fillRect(x,y, size+ rnd()*3, size + rnd()*3);
    }
  }
  function drawBlocks(c, rnd, rows, cols){
    c.fillStyle='#d4cab5';
    for(let i=0;i<rows;i++) for(let j=0;j<cols;j++){
      const x=-70 + j*9 + (rnd()-0.5)*2, y=-70 + i*9 + (rnd()-0.5)*2; if((i%3===0)||(j%3===0)) continue; c.fillRect(x,y,6,6);
    }
  }
  function drawBlocksRadial(c, rnd, rings, spokes){
    c.fillStyle='#d4cab5';
    for(let r=1;r<=rings;r++){
      for(let s=0;s<spokes;s++){
        const ang = s*(Math.PI*2/spokes) + (rnd()-0.5)*0.1;
        const rad = r*25 + 5 + (rnd()-0.5)*3; const x=Math.cos(ang)*rad, y=Math.sin(ang)*rad;
        c.fillRect(x,y, 6+rnd()*4, 6+rnd()*4);
      }
    }
  }
  function drawDocks(c, rnd){
    c.fillStyle='#d4cab5';
    for(let i=0;i<30;i++){
      const x = 10 + rnd()*80, y = -60 + rnd()*120; c.fillRect(x,y, 6, 6);
    }
  }

  // ---------- Names & Text
  function chooseType(rnd){
    const r=rnd(); if(r<0.5) return 'village'; if(r<0.78) return 'town'; if(r<0.95) return 'city'; if(r<0.98) return 'capital'; return 'town';
  }
  function makePlaceName(rnd, type){
    // Very lightweight namegen with a fantasy vibe
    const syll = ["ka","ra","bel","dor","an","mar","tul","ver","lin","os","is","ur","thal","ren","mor","val","ira","oth","brin","cor","eld","fen","gal","har","ion","jor","kel","lor","mir"];
    const parts = 2 + (rnd()<0.35?1:0);
    let name=''; for(let i=0;i<parts;i++){ name+= syll[Math.floor(rnd()*syll.length)]; }
    name = name.charAt(0).toUpperCase()+name.slice(1);
    if(type==='port' && rnd()<0.6) name = name + ' Bay';
    if(type==='capital' && rnd()<0.6) name = 'New ' + name;
    return name;
  }
  function makeFactionName(rnd){
    const p1=['Kingdom','Duchy','Realm','League','March','Barony','Confederacy'];
    const p2=['Alder','Cinder','Iron','Silver','Golden','Storm','Moon','Wolf','Raven','Ash'];
    const p3=['vale','reach','keep','fall','hold','mere','field','watch','crest','bar'];
    const name = p1[Math.floor(rnd()*p1.length)] + ' of ' + p2[Math.floor(rnd()*p2.length)] + p3[Math.floor(rnd()*p3.length)];
    return name;
  }
  function makePOIName(rnd,type){
    const base = {
      ruins:['Old Ruins','Fallen Halls','Broken Gate','Shattered Forum'],
      tower:['Wizard Tower','Watch Spire','Astral Tower','Ivory Spire'],
      shrine:['Moon Shrine','Sun Shrine','Ancient Shrine','Grove Shrine'],
      crypt:['Forgotten Crypt','Black Crypt','Bone Vault','Silent Tomb']
    }[type] || ['Ancient Site'];
    return base[Math.floor(rnd()*base.length)];
  }

  function describeCity(c){
    const f = CURRENT.factions[c.faction]?.name || '‚Äî';
    const flavor = {
      village: 'A quiet hamlet with scattered cottages and a small market square.',
      town: 'A bustling market town with tidy streets and watch towers.',
      city: 'A dense, lively city with multiple districts and ring roads.',
      capital: 'The grand capital, seat of power and culture across the realm.',
      port: 'A rugged harbor with docks, warehouses and salty air.'
    }[c.type];
    return `${flavor} Aligned to the ${f}. Prosperity is ${c.prosperity}.`;
  }

  function isNearAnyCity(cities,x,y,dist){
    for(const c of cities){ if(Math.hypot(c.x-x,c.y-y)<dist) return true; } return false;
  }

  // ---------- UI handlers
  document.getElementById('gen').addEventListener('click', ()=>{
    const seed = document.getElementById('seed').value || 'seed';
    const cities = parseInt(document.getElementById('cities').value||120,10);
    const rivers = parseInt(document.getElementById('rivers').value||10,10);
    const water = parseInt(document.getElementById('water').value||45,10);
    const chaos = parseInt(document.getElementById('chaos').value||45,10)/100;
    const detail = document.getElementById('detail').value;
    generate({seed, cities, rivers, waterPct: water, chaos, detail});
  });
  document.getElementById('export').addEventListener('click', ()=>{
    exportPNG();
  });

  // ---------- Export
  function exportPNG(){
    // Export the full map (base + overlay) at current world resolution
    const out = document.createElement('canvas');
    out.width = worldW; out.height = worldH; const c=out.getContext('2d');
    c.drawImage(baseOff,0,0); c.drawImage(overlayOff,0,0);
    const url = out.toDataURL('image/png');
    const a=document.createElement('a'); a.href=url; a.download=`map_${CURRENT.seed}.png`; a.click();
  }

  // ---------- Color helpers
  function hexToRgb(hex){ hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(x=>x+x).join(''); const num=parseInt(hex,16); return {r:(num>>16)&255,g:(num>>8)&255,b:num&255}; }
  function hslToHex(h,s,l){
    const a=s*Math.min(l,1-l); const f=(n,k=(n+h*12)%12)=>l - a*Math.max(-1, Math.min(k-3, Math.min(9-k,1)));
    const r = Math.round(255*f(0)), g=Math.round(255*f(8)), b=Math.round(255*f(4));
    return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
  }
  function hexWithAlpha(hex, a){ const {r,g,b} = hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }
  function escapeHtml(s){ return s.replace(/[&<>"]+/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m])); }

  // ---------- Initial setup
  function init(){
    resizeCanvas();
    // Initial transform: fit world to screen height
    const dpr=DPI();
    SCALE = Math.min( (W/worldW), (H/worldH) );
    panX = (W - worldW*SCALE)/2; panY = (H - worldH*SCALE)/2;
  }

  // Generate a starter map
  init();
  generate({ seed: 'valoria', cities: 120, rivers: 12, waterPct: 45, chaos: 0.45, detail:'med' });

})();

// ===== End IIFE =====
</script>
</body>
</html>
